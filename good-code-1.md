# 좋은 코드란 무엇인가?

- 디자이너와 기획의 의도를 충실히 구현한 코드.
- 최소한의 시스템 자원으로 효율적으로 실행되는 코드.
- 버그가 적은 코드

이와 같은 사용성, 성눙, 비용 등 비기눙 요구사항은 이 자리에서 다루지 않는다.
그저 순수하게 기능을 구현하는데 필요한 기술적인 부분에 집중한다.

기술적으로 좋은 코드가 무엇인지 알기 위해서 다양한 개발 방법들을 살펴보고 그들의 특징이 무엇인지 알아보자.

## 리팩토링

### 리팩토링 소개

case1.
아래는 마틴파울러의 리팩토링에서 제시한 bad/good 코드다.

```typescript
// bad case
```

```typescript
// good case
```

case2.
함수와 전역 변수를 잘 모으면 클래스가 된다.
범위를 조금 확장해서 클래스 레벨에서 좋은 코드를 찾아보자.

### 리팩토링과 변화

왜 읽기 쉬운 코드를 좋은 코드라고 할까?
마틴은 쓰기 보다는 읽기가 많다 등등의 이유를 들었다.
쓰기 위해서 읽는 것이고, 쓴다는 것은 변경한다는 뜻이다.
auto나 const와 같이 타입을 생략하는 이유도 간편한 표기 외에 타입 변화에 대응한다는 의미다.

왜 상태가 적은 클래스를 지향해야 하는가?
상태=변수를 통해서 메소드들이 연결되기 때문이다. 다시 말해서 의존성이 높아진다.

## 디자인 패턴

### 디자인 패턴

GoF의 30가지 패턴들은 어떤 문제가 있을 수 있고 어떻게 해결하면 좋은지를 소개한다.
전략 패턴에서 아래의 코드를 좋은 구조라고 소개한다.
왜 이런 구조를 지향하는 것일까?
다른 구조를 가지는 다른 패턴들은 왜 존재할까? 특징이 무엇일까?

> Impl을 직접 사용하지 않고 interface로 접근하는 다양한 예를 제시한다.
> 의존성을 관리해서 변화에 대응하는 전형적인 방법을 보여준다.

### 디자인패턴과 변화

추상화를 사용해서 의존성 관리.

## OOP

### OOP 소개

OOP는 도메인을 객체 단위로 분석하는 프로그래밍 기법이다. 왜 객체 단위로 분석을 할까? 그것이 현실의 개념과 잘 맞기 때문이다.
아래의 코드를 비교해 보자

> if-else 구문으로 프로그래밍을 하면 아무리 함수로 분리한다 해도 if-else가 중첩되는 등의 문제가 있을 것이다. OOP vs 알고리즘 사례를 찾아보자

이런 OOP의 잘 살리는 5가지의 원칙이 있다.

> SOLID 원칙 소개

### OOP와 변화

SOLID에서 제시하는 것은 변화에 대응할 수 있는 기본 원칙이다.

> SOLID 5원칙이 각각 변화에 어떤 영향을 주는지 서술한다.

## 아키텍쳐

클래스를 벗어나서 아키텍쳐라는 더 큰 범위를 생각해 보자.
여기서 아키텍쳐는 하나의 온전한 프로그램이나 서비스를 이룬 것을 말한다.
backend라면 Layerd Arch. frontend라면 MVC/MVVM을 대표적인 아키텍쳐라고 할 만하다.

### Layerd Arch.와 DDD 소개

### DDD와 변화

DDD는 언뜻 변화와 무관해 보일 지도 모르겠다. 요구사항의 변경은 최하위 레이어인 인프라스트럭쳐까지 영향을 준다.
도메인의 의미를 잘못 파악해서 구현하면 결국 많은 부분을 고치게 된다. 또 도메인이 변경되면 많은 부분을 고쳐야 하기 때문에 결국 변화할 수 없다. 도메인을 최상위에 놓는다는 것은 도메인이 변경될 때 영향을 최소화 하겠다는 뜻이다.
DDD는 도메인의 변화가 구현된 시스템에 끼치는 영향을 최소화 한다.

### MSA 소개

MSA는 다른 서비스의 의존성을 최소화 한다.
각각의 서비스들은 다른 서비스에 독립적으로 동작하도록 개발된다.
이것은 서비스를 사용하지 않는다는 것이 아니다. 서비스의 변화에 독립적이라는 뜻이다.
시스템 레벨에서도 마찬가지다

다양한 개발언어와 팀의 상황에 맞춰서 서비스를 개발한다.
모놀리식은 통일된 도구를 사용하게 된다.
다양한 상황에 대응하는 시스템 구조 = 변화를 수용

### MVC(MVVM) 소개

이들 아키텍쳐의 지향점은 무엇인가? 이 아키텍쳐의 공통된 장점은 무엇일까?
한 부분에서의 변화가 다른 부분으로 전파되지 않도록 한다.

### 아키텍쳐와 변화

아키텍쳐는 응집성/의존성을 전반에 걸쳐 준수하도록 한다.

## 테스트 자동화(TDD)

### 테스트 자동화 소개

우리가 흔히 이용하는 비행기에 센서가 없다고 상상해 보자. 출발 전에 문제가 발생하면 그나마 다행이겠지만 어디에서 문제가 발생하는지 알 수 있는 방법이 없기 때문에 원인을 찾기 위해서 모든 부분을 살펴봐야 할 것이다.
그리고 그것이 테스트 자동화가 갖춰지지 않은 프로젝트의 상황이다. 그럼에도 테스트 자동화를 갖추지 않는 이유는 크게 두 가지인데.(너무 당연한 3번은 제외하고)

1. 오류가 발생해도 피해가 크지 않다.
2. 비행기 만큼 복잡하지는 않아서 어떻게든 찾아낼 수 있다.
3. 너무 당연하지만 테스트를 작성하기에는 실력이 부족하다.

다양한 테스트 방법들. 유닛테스트, 엔드2엔드 테스트 등등.
여기서 언급하는 것은 주로 유닛테스트다.

### TDD 소개

TDD는 지속적으로 변화하는 코드를 테스트 하기 위해서다. 테스트 자동화와 TDD는 엄밀하게는 구분되어야 한다. TDD는 테스트를 주도적으로 개발하는 것인데 부수적인(혹은 주목적일지도) 효과로 인터페이스를 먼저 정의하게 되고 이것은 자연스럽게 설계 후 구현으로 이어진다.
TDD로 얻게 되는 장점으로 켄트백은 아래와 제시한다.

-
-
-

추가로 자연스럽게 설계를 우선하게 되는 것이 장점이다.

### 테스트 자동화와 변화

비행기는 내부의 부품이 계속 마모되는 변화가 발생한다. 소프트웨어는 외부 환경이 변화한다. 변화가 어느 쪽에서 일어나든 그것은 시스템 전반에 영향을 준다. 그 시스템이 복잡하다면 테스트 없이 생존할 수 없다.
테스트 자동화는 일반적이다. 우리가 사용하는 대부분의 개발 프레임워크의 가이드를 보면 테스트가 있다.

## 애자일 방법론

### 애자일 소개

집을 지을 때 처음 설계를 마치고 시공을 하는 중에도 끊임없이 수정하고 싶은 욕구가 생긴다. 여기에 전등을 달고 저기에 스위치를 옮기고 창은 좀 줄이고 등등.
이것은 인간이 창의적이기 때문이다. 그리고 이런 과정은 소프트웨어를 개발할 때도 마찬가지다.
요구사항은 계속 변한다. 그것이 고객의 요구이든 분석 단계에서 오류가 있든 간에 말이다.
애자일은 이런 요구사항의 변화에 대응하기 위한 개발 전략이다.

### 애자일과 변화

## cross-platform

### Java, NET 소개

.NET이 뒤늦게 나왔고 비교적 세련된 기술이다.
그럼에도 시장 점유율은 낮은 편이다. 개선된 장점이 흐름을 바꿀 만큼 크지 않은 것이다.

### 자마린, QT 소개

왜 망했나?

### Flutter, React Native 소개

### Docker 소개

> Linux® 컨테이너는 시스템의 나머지 부분과 분리된 1개 이상의 프로세스 세트입니다. 이러한 프로세스를 실행하는 데 필요한 모든 파일은 고유한 이미지에서 제공되므로, Linux 컨테이너는 개발 단계에서 테스트, 프로덕션에 이르기까지 이식성과 일관성을 유지할 수 있습니다. 따라서 전통적인 테스트 환경을 복제하는 데 의존하는 개발 파이프라인보다 사용 시점을 훨씬 더 앞당길 수 있습니다. 대중성과 사용의 편의성 때문에 컨테이너 역시 IT 보안의 중요한 부분입니다.

실행에 필요한 환경을 모두 하나의 패키지로 관리한다는 것은 응집성/의존성의 특징이다.

### 크로스 플랫폼과 변화

ios/android를 지원하는 Flutter, Java, .NET은 OS의 변화에 대응하기 쉬운 환경을 제공한다. 물론 one source multi use가 플랫폼의 의도였겠으나, 다양한 환경에 적응하는 플랫폼이라는 것은 변화에 잘 대응하는 플랫폼이라는 말과 같다.

## ORM(이것도 억지스럽네3)

### ORM 소개

ORM과 OOP의 관계

### ORM과 변화

typeorm, mybatis와 같은 ORM들은 다양한 SQL을 통일된 방법으로 사용할 수 있게 한다.
SQL 마다 문법이 조금씩 다르다. 본래의 취지는 말 그대로 Object Relation Modeling이겠으나 부수적인 효과로 통일된 인터페이스를 통한 SQL에 독립적인 코드를 지원한다.

## 결론

### 좋은 코드의 특징

지금까지 살펴본 개발방법과 도구들의 공통점은 변화에 대응한다는 것이다.
변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다.
그것은 코드도 마찬가지인데 좋은 코드는 변화에 적응하기 쉬운 특징을 가진다.
변화에 대응하기 좋은 코드의 특징은 의존성이 낮고 응집성이 높은 것이다.

그림(의존성/응집성)

그래서 패턴이나 아키텍쳐의 핵심은 규모가 다를 뿐이지 의존성/응집성에 대한 이야기다

의존성/응집성
다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 한다.

몇몇 책에서도 의존성과 응집성을 직접적으로 이야기 한다.
그렇지 않더라도 방법과 방법론에 대한 '모든' 서적은 변화에 대한 이야기다.

많은 이들이 개발 언어와 도구에 집착하는 것으로 보인다.
그러나 문제의 본질을 통찰하고 예측할 수 있다면 대응은 비교적 쉬운 편이고 도구도 올바르게 사용할 수 있다.

### 소프트웨어가 변화하는 이유

그렇다면 소프트웨어 개발은 왜 변화에 이토록 민감할까?

> 서적에서 제시한 여러 특징들 나열

하드웨어의 발전 만큼이나 소프트웨어 산업은 빠르게 변화하고 발전하고 있다.
이 두 분야의 발전은 불가분의 관계다.
예를 들어 하드웨어가 10배 정도 빨라지면 가능해지는 여러 기능들을 소프트웨어가 구현한다.
CPU가 충분히 작아지면서 스마트폰이 생겼다. 그로 인해 탄생하는 많은 소프트웨어들을 생각해 보자.
CPU가 단일코어로 성능향상이 어려워지면서 이제는 8개의 코어는 기본이 됐다.
그에 맞춰서 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화했다.
통신 인프라가 발전하면서 클라우드 컴퓨팅이라는 개념이 생겼다.
CPU와 메모리가 발전하면서 가상화를 쉽게 수행하게 됐다.

가까운 미래에는 SSD의 속도가 충분히 빨라져서 메인 메모리의 개념이 사라질지도 모른다.
그렇게 되면 소프트웨어에는 어떤 변화가 일어날까.
VR이 대중화 된다면 그에 맞는 새로운 인터페이스도 기대할 수 있다.
이렇게 발전하는 하드웨어에 맞춰서 그에 맞는 새로운 플랫폼과 개념들이 생겨나고 있다.
소프트웨어의 발전이 하드웨어에 영향을 주기도 하지만 보통은 하드웨어의 발전에 맞춰서 소프트웨어가 따라간다.

추가로 변경과 공유가 쉽기 때문에 규격화가 안 된다.
복제가 가능하다. 같은 물건을 만들기 위해서 공장을 다시 지을 필요가 없다.
한 번 잘 만들어 놓으면 많은 사람들이 여러번 사용할 수 있다.
변경의 효용이 어려움을 능가하는 것이다. 즉, 비용 효율적이다.

건물은 복제가 되지 않고 외부 환경의 변화도 크지 않다.

###
