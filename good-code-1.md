# 좋은 코드란 무엇인가?

- 디자이너와 기획의 의도를 충실히 구현한 코드.
- 최소한의 시스템 자원으로 효율적으로 실행되는 코드.
- 버그가 적은 코드

이와 같은 사용성, 성눙, 비용 등 비기눙 요구사항은 이 자리에서 다루지 않는다.
그저 순수하게 기능을 구현하는데 필요한 기술적인 부분에 집중한다.

기존의 이론서적들은 포괄적이고 다양한 사례와 의견을 제시한다. 충분한 경험을 가진 시니어에게는 도움이 되겠지만 주니어에게는 혼란을 가중한다.
여기서는 가장 추천하는 단일 케이스를 제시한다.

기술적으로 좋은 코드가 무엇인지 알기 위해서 다양한 개발 방법들을 살펴보고 그들의 특징이 무엇인지 알아보자.

## 리팩토링

### 리팩토링 소개

엄밀한 의미의 리팩토링은 기능은 그대로 두고 코드를 개선하는 것이다.
그러나 여기서는 좀 더 포괄적인 개선을 리팩토링으로 취급한다.

case1.
아래는 마틴파울러의 리팩토링에서 제시한 bad/good 코드다.

```typescript
// bad case
```

```typescript
// good case
```

case2.
함수와 전역 변수를 잘 모으면 클래스가 된다.
범위를 조금 확장해서 클래스 레벨에서 좋은 코드를 찾아보자.

### 리팩토링과 변화

왜 읽기 쉬운 코드를 좋은 코드라고 할까?
마틴은 쓰기 보다는 읽기가 많다 등등의 이유를 들었다.
쓰기 위해서 읽는 것이고, 쓴다는 것은 변경한다는 뜻이다.
auto나 const와 같이 타입을 생략하는 이유도 간편한 표기 외에 타입 변화에 대응한다는 의미다.

왜 상태가 적은 클래스를 지향해야 하는가?
상태=변수를 통해서 메소드들이 연결되기 때문이다. 다시 말해서 의존성이 높아진다.

## OOP

### OOP 소개

OOP는 도메인을 객체 단위로 분석/구현하는 프로그래밍 기법이다. 왜 객체 단위로 분석을 할까? 그것이 현실의 개념과 잘 맞기 때문이다.
아래의 코드를 비교해 보자

> if-else 구문으로 프로그래밍을 하면 아무리 함수로 분리한다 해도 if-else가 중첩되는 등의 문제가 있을 것이다. OOP vs 알고리즘 사례를 찾아보자
> https://www.geeksforgeeks.org/brief-overview-comparison-of-object-oriented-programming-from-c-to-java/

> https://www.geeksforgeeks.org/differences-between-procedural-and-object-oriented-programming/

이런 OOP의 5가지의 원칙이 있다.

> SOLID 원칙 소개

객체지향코드는 분석이 어렵다. 알고리즘 코드는 한 곳에 있고 호출하는 함수도 간단하고 어떤 값을 가져오는지 알기쉽다.
객체지향은 일처리를 다른 객체에 위임하고 결과만 받는다. 코드는 어딘가에 분산되어 있다.
객체지향을 잘 분석하기 위해서는 거기에 사용된 아키텍쳐를 이해하고 있어야 한다.
코드에 아키텍쳐라고 부를만한 것이 없다면 OOP든 알고리즘이든 어렵기는 마찬가지가 된다.

OOP는 쉽지 않다.

> 엔터프라이즈 아키텍처 36p
> 도메인 모댈(122)을 사용하는 데 따르는 비용은 사용의 복잡성과 데이터 원본 계층의 복잡성이 다. 리치 객체 모델을 처음 시작하는 개발자가 도메인 모댈(122)에 익숙해지는 데는 시간이 펼 요하다. 이 패턴을 사용하는 프로젝트에서 몇 달 동안 작업한 후에야 비로소 사고방식의 전환을 이루는 경우도 많다 일단 도메인 모댈(122)을 사용하는 데 익숙해진 후에는 이후의 모든 작업 이 수월해진다. 필자와 같은 객체 신봉자가 이렇게 한 명 늘어난다. 그러나 이러한 전환을 끝내 이루지 못하는 개발자들도 상당수 있다.

### OOP와 변화

OOP를 학습할 때 할 일을 객체에 일임한다는 것을 알 것이다. 의존성과 응집성을 관리하는 것이다.
이 원칙은 디자인 패턴에서 자세히 나온다.
SOLID에서 제시하는 것은 변화에 대응할 수 있는 기본 원칙이다.

> SOLID 5원칙이 각각 변화에 어떤 영향을 주는지 서술한다.

## 디자인 패턴

### 디자인 패턴 소개

종종 디자인 패턴을 클래스 수준에서 적용하는 기술로 알고있는 프로그래머들이 있다. 그러나 이것은 말 그대로 패턴이기 때문에 다양한 곳에서 나타난다. MSA에서 Message Broker는 옵저버 패턴이다. API Gateway는 전략 패턴의 일종으로 해석할 수 있다.
GoF의 30가지 패턴들은 어떤 문제가 있을 수 있고 어떻게 해결하면 좋은지를 소개한다.
전략 패턴에서 아래의 코드를 좋은 구조라고 소개한다.
왜 이런 구조를 지향하는 것일까?
다른 구조를 가지는 다른 패턴들은 왜 존재할까? 특징이 무엇일까?

> Impl을 직접 사용하지 않고 interface로 접근하는 다양한 예를 제시한다.
> 의존성을 관리해서 변화에 대응하는 전형적인 방법을 보여준다.

### 디자인 패턴과 변화

추상화를 사용해서 의존성 관리.

## 아키텍쳐

몇 가지 대표적인 아키텍쳐를 살펴보자.
backend라면 Layerd Arch와 MSA,
frontend라면 MVC/MVVM을 대표적인 아키텍쳐라고 할 만하다.

### Layerd Arch

\*\* 전체적으로 엔터프라이즈 아키텍처를 참고해서 설명한다.

> 마틴 파울러, 엔터프라이즈 아키텍처, 9p, 들어가며
>
> 필자가 가장 중요하게 여기는 아키텍처 패턴은 계층(layer)의 아 키텍처 패턴이며 이에 대해서는 1장에서 자세하게 다룬다. 요의f하면 이 책은 엔터프라이즈 애 플리케이션을 계층으로 분할하는 방법과 이러한 계층이 상호작용핸 방법에 대한 책이다. 중 요한 엔터프라이즈 애플리케이션은 어떤 형식으로든 계층형 아키텍처를 사용하지만 경우에

레이어로 나눌 때 주의해야 할 것은 무리하게 캡슐화 하려는 욕심이다.
각각의 레이어는 독립적이다. 적어도 상위 레이어를 알 수 없다. 각 레이어를 오고 갈 때 dto를 통한 변환 작업이 이루어진다.
적어도 db->model이 그렇다. model->service도 인터페이스(microservice, rest api)에 따른 변환 작업이 필요하다.
이것을 DB에서 Service까지 아우르는 하나의 클래스로 캡슐화(공통화) 하면 각각의 레이어에서 발생하는 변경사항이 전체 레이어에 영향을 준다. 이것은 레이어로 나눈 것이 아니다.

> 계층은 전체가 효과적으로 캡슐화되지 않는다 그 결과 뭔가를 변경했을 때 다른 계층에 영흔F을 미치는 경우가 있다 계층형 앤터프라이즈 애플리케이션에서 볼 수 있는 전형적인 예는 UI에 표시해야 하는 필드가 데이터베 이스에도 있어야 하므로 그 시이어| 있는 모든 계층에 해당 필드를 추가해야 한다는 것이다‘

레이어를 엄격하게 나누는 것에 대해서 마틴은 아래와 같이 우려했다.

> 사실 필자가 지나치게 독단적으로 주장하는 것은 아닌지 염려스러운 마음도 있다. 앨런 나이트 는 이 책을 검토하면서 “이 논리를 UI에 넣는 것은 지옥으로 들어가는 문일 수도 있고 독단적 순수주의자만 반대할 완전히 합리적 선택일 수도 있다”라고 이야기했다. 우리가 염려히는 것은 둘 다 맞는 이야기이기 때문이다.

내 생각에는 레이어로 나누는 것은 대규모 혹은 다수의 참여자를 고려한 것이다. 그렇다면 다소 불편함이 있더라도 일관성을 유지하는 것이 옳다고 믿는다. 지금은 괜찮아 보여도 시간이 지나고 변화하면서 결국엔 일관된 코드를 지향하게 된다. 물론, 프로젝트의 규모와 수명 등을 종합적으로 고려해야 할 것이다.
위의 마틴의 언급은 2002년에 출판된 책에 실린 것이기 때문에 마틴도 생각을 바꿨을지도 모른다.

### DDD 소개

실제 DDD에서는 도메인 전문가(고객)와 원활한 의사소통을 위해서 유비쿼터스 언어를 정의하는 것까지 소개하고 있다.
여기서 DDD는 Layerd Arch의 좀 더 발전된 혹은 세련된 아키텍쳐로 바라본다.
즉, Layerd Arch 보다 Domain이 중심이 되는 아키텍쳐를 구성하는 것을 DDD로 언급한다.
내가 DDD를 학습할 때 어려웠던 것은 Domain이 중심이 되어야 하는데 레이어는 Service->Model->Infra 순서다.
Domain은 Infra를 몰라야 하는데 아키텍쳐는 알아야만 하도록 구성되어 있다.

여기까지만 생각하면 레이어는 Service->Infra->Model이 되어야 할 것 같다. Model 자신이 참조하는 것은 아무것도 없기 때문에.
Model이 중심이 되는 것과 Model이 마지막 레이어인 것은 다르다. 다른 계층은 얼마든지 생길 수 있다.
그러니까 차라리 Service->Model<-Infra로 해석하는 것이 보다 정확해 보인다.

### MSA 소개

MSA는 다른 서비스의 의존성을 최소화 한다.
각각의 서비스들은 다른 서비스에 독립적으로 동작하도록 개발된다.
이것은 서비스를 사용하지 않는다는 것이 아니다. 서비스의 변화에 독립적이라는 뜻이다.
시스템 레벨에서도 마찬가지다

다양한 개발언어와 팀의 상황에 맞춰서 서비스를 개발한다.
모놀리식은 통일된 도구를 사용하게 된다.
다양한 상황에 대응하는 시스템 구조 = 변화를 수용

### MVC(MVVM) 소개

MVC에서 MVP를 거쳐서 지금은 MVVM을 많이 사용하는 것 같다. .NET의 WPF는 물론이고 iOS(SwiftUI)와 android도 MVVM 구조를 지원한다.
MVC든 MVVM이든 요점은 Model과 View를 분리한다는 것이다.

### 아키텍쳐와 변화

이들 아키텍쳐의 지향점은 무엇인가? 이 아키텍쳐의 공통된 장점은 무엇일까?
한 부분에서의 변화가 다른 부분으로 전파되지 않도록 한다.
아키텍쳐는 응집성/의존성을 전반에 걸쳐 준수하도록 한다.

아키텍쳐는 최대한 단순해야 한다. 규칙이 복잡할수록 고려하지 못한 예외 사항이 발생하기 쉽고 대처하기 어렵다. 또한 그 만큼 외부 변화에 취약하다.

DDD는 언뜻 변화와 무관해 보일 지도 모르겠다. 요구사항의 변경은 최하위 레이어인 인프라스트럭쳐까지 영향을 준다.
도메인의 의미를 잘못 파악해서 구현하면 결국 많은 부분을 고치게 된다. 또 도메인이 변경되면 많은 부분을 고쳐야 하기 때문에 결국 변화할 수 없다. 도메인을 최상위에 놓는다는 것은 도메인이 변경될 때 영향을 최소화 하겠다는 뜻이다.
DDD는 도메인의 변화가 구현된 시스템에 끼치는 영향을 최소화 한다.

요즘의 최신 백엔드 프레임워크는 DDD에 기반한 Layerd arch와 MSA를 잘 지원하는 방향으로 발전하고 있다.

## 테스트 자동화(TDD)

### 테스트 자동화 소개

우리가 흔히 이용하는 비행기에 센서가 없다고 상상해 보자. 출발 전에 문제가 발생하면 그나마 다행이겠지만 어디에서 문제가 발생하는지 알 수 있는 방법이 없기 때문에 원인을 찾기 위해서 모든 부분을 살펴봐야 할 것이다.
그리고 그것이 테스트 자동화가 갖춰지지 않은 프로젝트의 상황이다. 그럼에도 테스트 자동화를 갖추지 않는 이유는 크게 두 가지인데.(너무 당연한 3번은 제외하고)

1. 오류가 발생해도 피해가 크지 않다.
2. 비행기 만큼 복잡하지는 않아서 어떻게든 찾아낼 수 있다.
3. 너무 당연하지만 테스트를 작성하기에는 실력이 부족하다.

다양한 테스트 방법들. 유닛테스트, 엔드2엔드 테스트 등등.
여기서 언급하는 것은 주로 유닛테스트다.

### TDD 소개

TDD는 지속적으로 변화하는 코드를 테스트 하기 위해서다. 테스트 자동화와 TDD는 엄밀하게는 구분되어야 한다. TDD는 테스트를 주도적으로 개발하는 것인데 부수적인(혹은 주목적일지도) 효과로 인터페이스를 먼저 정의하게 되고 이것은 자연스럽게 설계 후 구현으로 이어진다.
TDD로 얻게 되는 장점으로 켄트백은 아래와 제시한다.

-
-
-

추가로 자연스럽게 설계를 우선하게 되는 것이 장점이다.

### 테스트 자동화와 변화

비행기는 내부의 부품이 계속 마모되는 변화가 발생한다. 소프트웨어는 외부 환경이 변화한다. 변화가 어느 쪽에서 일어나든 그것은 시스템 전반에 영향을 준다. 그 시스템이 복잡하다면 테스트 없이 생존할 수 없다.
테스트 자동화는 일반적이다. 우리가 사용하는 대부분의 개발 프레임워크의 가이드를 보면 테스트가 있다.

## 애자일 방법론

### 애자일 소개

집을 지을 때 처음 설계를 마치고 시공을 하는 중에도 끊임없이 수정하고 싶은 욕구가 생긴다. 여기에 전등을 달고 저기에 스위치를 옮기고 창은 좀 줄이고 등등.
이것은 인간이 창의적이기 때문이다. 그리고 이런 과정은 소프트웨어를 개발할 때도 마찬가지다.
요구사항은 계속 변한다. 그것이 고객의 요구이든 분석 단계에서 오류가 있든 간에 말이다.
애자일은 이런 요구사항의 변화에 대응하기 위한 개발 전략이다.

### 애자일과 변화

## cross-platform

### Java, NET 소개

.NET이 뒤늦게 나왔고 비교적 세련된 기술이다.
그럼에도 시장 점유율은 낮은 편이다. 개선된 장점이 흐름을 바꿀 만큼 크지 않은 것이다.

### 자마린, QT 소개

왜 망했나?

### Flutter, React Native 소개

### Docker 소개

> Linux® 컨테이너는 시스템의 나머지 부분과 분리된 1개 이상의 프로세스 세트입니다. 이러한 프로세스를 실행하는 데 필요한 모든 파일은 고유한 이미지에서 제공되므로, Linux 컨테이너는 개발 단계에서 테스트, 프로덕션에 이르기까지 이식성과 일관성을 유지할 수 있습니다. 따라서 전통적인 테스트 환경을 복제하는 데 의존하는 개발 파이프라인보다 사용 시점을 훨씬 더 앞당길 수 있습니다. 대중성과 사용의 편의성 때문에 컨테이너 역시 IT 보안의 중요한 부분입니다.

실행에 필요한 환경을 모두 하나의 패키지로 관리한다는 것은 응집성/의존성의 특징이다.

### 크로스 플랫폼과 변화

ios/android를 지원하는 Flutter, Java, .NET은 OS의 변화에 대응하기 쉬운 환경을 제공한다. 물론 one source multi use가 플랫폼의 의도였겠으나, 다양한 환경에 적응하는 플랫폼이라는 것은 변화에 잘 대응하는 플랫폼이라는 말과 같다.

## ORM(이것도 억지스럽네3)

### ORM 소개

ORM과 OOP의 관계

### ORM과 변화

typeorm, mybatis와 같은 ORM들은 다양한 SQL을 통일된 방법으로 사용할 수 있게 한다.
SQL 마다 문법이 조금씩 다르다. 본래의 취지는 말 그대로 Object Relation Modeling이겠으나 부수적인 효과로 통일된 인터페이스를 통한 SQL에 독립적인 코드를 지원한다.

## 결론

### 좋은 코드의 특징

지금까지 살펴본 개발방법과 도구들의 공통점은 변화에 대응한다는 것이다.
변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다.
그것은 코드도 마찬가지인데 좋은 코드는 변화에 적응하기 쉬운 특징을 가진다.
변화에 대응하기 좋은 코드의 특징은 의존성이 낮고 응집성이 높은 것이다.

그림(의존성/응집성)

그래서 패턴이나 아키텍쳐의 핵심은 규모가 다를 뿐이지 의존성/응집성에 대한 이야기다

의존성/응집성
다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 한다.

몇몇 책에서도 의존성과 응집성을 직접적으로 이야기 한다.
그렇지 않더라도 방법과 방법론에 대한 '모든' 서적은 변화에 대한 이야기다.

많은 이들이 개발 언어와 도구에 집착하는 것으로 보인다.
그러나 문제의 본질을 통찰하고 예측할 수 있다면 대응은 비교적 쉬운 편이고 도구도 올바르게 사용할 수 있다.

### 소프트웨어가 변화하는 이유

그렇다면 소프트웨어 개발은 왜 변화에 이토록 민감할까?

> 서적에서 제시한 여러 특징들 나열

하드웨어의 발전 만큼이나 소프트웨어 산업은 빠르게 변화하고 발전하고 있다.
이 두 분야의 발전은 불가분의 관계다.
예를 들어 하드웨어가 10배 정도 빨라지면 가능해지는 여러 기능들을 소프트웨어가 구현한다.
CPU가 충분히 작아지면서 스마트폰이 생겼다. 그로 인해 탄생하는 많은 소프트웨어들을 생각해 보자.
CPU가 단일코어로 성능향상이 어려워지면서 이제는 8개의 코어는 기본이 됐다.
그에 맞춰서 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화했다.
통신 인프라가 발전하면서 클라우드 컴퓨팅이라는 개념이 생겼다.
CPU와 메모리가 발전하면서 가상화를 쉽게 수행하게 됐다.

가까운 미래에는 SSD의 속도가 충분히 빨라져서 메인 메모리의 개념이 사라질지도 모른다.
그렇게 되면 소프트웨어에는 어떤 변화가 일어날까.
VR이 대중화 된다면 그에 맞는 새로운 인터페이스도 기대할 수 있다.
이렇게 발전하는 하드웨어에 맞춰서 그에 맞는 새로운 플랫폼과 개념들이 생겨나고 있다.
소프트웨어의 발전이 하드웨어에 영향을 주기도 하지만 보통은 하드웨어의 발전에 맞춰서 소프트웨어가 따라간다.

추가로 변경과 공유가 쉽기 때문에 규격화가 안 된다.
복제가 가능하다. 같은 물건을 만들기 위해서 공장을 다시 지을 필요가 없다.
한 번 잘 만들어 놓으면 많은 사람들이 여러번 사용할 수 있다.
변경의 효용이 어려움을 능가하는 것이다. 즉, 비용 효율적이다.

건물은 복제가 되지 않고 외부 환경의 변화도 크지 않다.

### 급변하는 개발환경에 대처하는 자세

React, NodeJS와 같은 응용기술이 변화가 빨라서 한 프로그래머가 여러 영역에 걸쳐서 경험을 쌓기가 쉽지 않다.
패턴과 아키텍처와 같은 개발 이론의 지식은 쉽게 얻을 수 없으나 얻으면 모든 분야에 유용하다. 설계 없는 개발이 가능하겠는가.
