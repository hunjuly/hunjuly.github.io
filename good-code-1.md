# 좋은 코드의 특징

좋은 코드란 무엇일까?

- 디자이너와 기획의 의도를 충실히 구현한 코드.
- 최소한의 시스템 자원으로 효율적으로 실행되는 코드.
- 버그가 적은 코드

이와 같은 사용성, 성눙, 비용 등 비기눙 요구사항은 이 자리에서 다루지 않는다.
그저 순수하게 기술적인 부분만을 얘기하려고 한다.

기술적으로 좋은 프로그램이 무엇인지 알기 위해서 다양한 개발 방법들을 살펴보자.

## 리팩토링

### 리팩토링 소개

case1.
아래는 마틴파울러의 리팩토링에서 제시한 bad/good 코드다.

```typescript
// bad case
```

```typescript
// good case
```

### 리팩토링과 변화

왜 읽기 쉬운 코드를 좋은 코드라고 할까?
마틴은 쓰기 보다는 읽기가 많다 등등의 이유를 들었다.
쓰기 위해서 읽는 것이고, 쓴다는 것은 변경한다는 뜻이다.
auto나 const와 같이 타입을 생략하는 이유도 간편한 표기 외에 타입 변화에 대응한다는 의미다.

case2.
함수와 전역 변수를 잘 모으면 클래스가 된다.
범위를 조금 확장해서 클래스 레벨에서 좋은 코드를 찾아보자.
상태가 적은 클래스를 지향하도록 한다. 왜?

## 디자인 패턴

### 디자인 패턴

GoF의 30가지 패턴들은 어떤 문제가 있을 수 있고 어떻게 해결하면 좋은지를 소개한다.
전략 패턴에서 아래의 코드를 좋은 구조라고 소개한다.
왜 이런 구조를 지향하는 것일까?
다른 구조를 가지는 다른 패턴들은 왜 존재할까? 특징이 무엇일까?

### 디자인패턴과 변화

## OOP

### OOP 소개

> SOLID 원칙 소개

### OOP와 변화

OOP는 도메인을 객체 단위로 분석하는 프로그래밍 기법이다. 왜 객체 단위로 분석을 할까? 그것이 현실의 개념과 잘 맞기 때문이다.
현실의 개념과는 다른 코드를 작성한다면 코드가 발전하면서 점점 현실과 어긋나게 된다. 즉, 코드가 점진적으로 변경되면서 발생하는 현실과의 괴리를 피하기 위해서다.

## 테스트 자동화(TDD)

### 테스트 자동화 소개

### TDD 소개

TDD는 지속적으로 변화하는 코드를 테스트 하기 위해서다. 테스트 자동화와 TDD는 엄밀하게는 구분되어야 한다. TDD는 테스트를 주도적으로 개발하는 것인데 부수적인(혹은 주목적일지도) 효과로 인터페이스를 먼저 정의하게 되고 이것은 자연스럽게 설계 후 구현으로 이어진다.
TDD로 얻게 되는 장점으로 켄트백은 아래와 제시한다.

-
-
-

추가로 자연스럽게 설계를 우선하게 되는 것이 장점이다.

### 테스트 자동화와 변화

## 아키텍쳐

### Layerd 소개

클래스를 벗어나서 아키텍쳐라는 더 큰 범위를 생각해 보자.
여기서 아키텍쳐는 하나의 온전한 프로그램이나 서비스를 이룬 것을 말한다.
backend라면 Layerd Arch. frontend라면 MVC/MVVM을 대표적인 아키텍쳐라고 할 만하다.

### MVC(MVVM) 소개

이들 아키텍쳐의 지향점은 무엇인가? 이 아키텍쳐의 공통된 장점은 무엇일까?
한 부분에서의 변화가 다른 부분으로 전파되지 않도록 한다.

## 애자일 방법론

### 애자일 소개

요구사항의 변화에 대응하기 위한 개발 전략이다.

### 애자일과 변화

## DDD (좀 억지스럽네..)

### DDD 소개

### DDD와 변화

DDD는 언뜻 변화와 무관해 보일 지도 모르겠다. 요구사항의 변경은 최하위 레이어인 인프라스트럭쳐까지 영향을 준다.
도메인의 의미를 잘못 파악해서 구현하면 결국 많은 부분을 고치게 된다. 또 도메인이 변경되면 많은 부분을 고쳐야 하기 때문에 결국 변화할 수 없다. 도메인을 최상위에 놓는다는 것은 도메인이 변경될 때 영향을 최소화 하겠다는 뜻이다.

## MSA??(이것도 억지스럽네)

### MSA 소개

MSA는 다른 서비스의 의존성을 최소화 한다.
각각의 서비스들은 다른 서비스에 독립적으로 동작하도록 개발된다.
이것은 서비스를 사용하지 않는다는 것이 아니다. 서비스의 변화에 독립적이라는 뜻이다.
시스템 레벨에서도 마찬가지다

### MSA와 변화의 소개

다양한 개발언어와 팀의 상황에 맞춰서 서비스를 개발한다.
모놀리식은 통일된 도구를 사용하게 된다.
다양한 상황에 대응하는 시스템 구조 = 변화를 수용

## cross-platform

### Java, NET 소개

.NET이 뒤늦게 나왔고 비교적 세련된 기술이다.
그럼에도 시장 점유율은 낮은 편이다. 개선된 장점이 흐름을 바꿀 만큼 크지 않은 것이다.

### 자마린, QT 소개

왜 망했나?

### Flutter, React Native 소개

### 크로스 플랫폼과 변화

ios/android를 지원하는 Flutter, Java, .NET은 OS의 변화에 대응하기 쉬운 환경을 제공한다. 물론 one source multi use가 플랫폼의 의도였겠으나, 다양한 환경에 적응하는 플랫폼이라는 것은 변화에 잘 대응하는 플랫폼이라는 말과 같다.

## ORM(이것도 억지스럽네3)

### ORM 소개

ORM과 OOP의 관계

### ORM과 변화

typeorm, mybatis와 같은 ORM들은 다양한 SQL을 통일된 방법으로 사용할 수 있게 한다.
SQL 마다 문법이 조금씩 다르다. 본래의 취지는 말 그대로 Object Relation Modeling이겠으나 부수적인 효과로 통일된 인터페이스를 통한 SQL에 독립적인 코드를 지원한다.

## 결론

### 좋은 코드의 특징

좋은 코드는 변화에 적응하기 쉬운 특징을 가진다.
지금까지 살펴본 개발방법과 도구들의 공통점은 변화에 대응응한다는 것이다.
변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다.
변화에 대응하기 좋은 코드의 특징은 의존성이 낮고 응집성이 높은 것이다.

그림(의존성/응집성)

그래서 패턴이나 아키텍쳐의 핵심은 규모가 다를 뿐이지 의존성/응집성에 대한 이야기다

의존성/응집성
다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 한다.

몇몇 책에서도 의존성과 응집성을 직접적으로 이야기 한다.
그렇지 않더라도 방법과 방법론에 대한 '모든' 서적은 변화에 대한 이야기다.

많은 이들이 개발 언어와 도구에 집착하는 것으로 보인다.
그러나 문제의 본질을 통찰하고 예측할 수 있다면 대응은 비교적 쉬운 편이고 도구도 올바르게 사용할 수 있다.

### 소프트웨어가 변화하는 이유

소프트웨어 개발은 왜 변화에 이토록 민감할까?

> 서적에서 제시한 여러 특징들 나열

추가로 복제가 가능하다. 같은 물건을 만들기 위해서 공장을 다시 지을 필요가 없다.
한 번 잘 만들어 놓으면 많은 사람들이 여러번 사용할 수 있다.
변경의 효용이 어려움을 능가하는 것이다. 즉, 비용 효율적이다.

건물은 복제가 되지 않고 외부 환경의 변화도 크지 않다.
