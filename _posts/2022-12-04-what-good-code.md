---
layout: post
title: "1. 좋은 코드란 무엇인가?"
---

사람은 누구나 자신이 노력하는 분야에서 실력을 인정받기를 바란다. 프로그래머도 이와 다르지 않다. 그러나 실력의 기준은 사람마다, 상황마다 다르다. 어떤 이는 알고리즘 같은 기본기를 중요시하며, 다른 이는 빠르게 기능을 구현하는 것을 실력의 척도로 본다. 여기에 디버깅 능력, 최신 기술에 대한 지식 등을 갖춘 사람은 일반적으로 실력있는 프로그래머로 인정받는다.

그러나, 이것이 전부일까? SDK의 문서를 읽고 기능을 구현하는 것은 프로그래밍의 기본이다. 알고리즘도 몇 개를 이해하면 나머지는 그저 개인의 재능에 따른 응용일 뿐이다. 과연 주니어와 시니어 프로그래머의 차이는 단지 이런 기술 숙련도에 있는 것일까?

나는 '좋은 코드'를 작성할 수 있는 능력이 프로그래머의 평가 기준이 된다고 생각한다. 이는 프로그래머의 기술적 능력에 한정된 말이다. 좋은 프로그래머라면 기술력뿐만 아니라 훌륭한 커뮤니케이션 능력과 현명함도 갖추어야 한다.

좋은 코드란 어떤 것인가? 이는 추상적이고 주관적인 개념으로, 상황에 따라 그 정의는 변할 수 있다. 하지만, 대부분의 프로그래머들은 '읽기 쉽고 변경하기 쉬운 코드'를 좋은 코드라고 이야기한다. 그리고 코드를 읽는 목적이 결국 코드를 변경하기 위함이기 때문에, '변경하기 쉬운 코드'라는 간략한 정의를 내릴 수 있다.

좋은 코드에 대한 정의는 사람마다, 상황마다 달라진다. 그래서 이 글은 '좋은 코드가 무엇인가' 그리고 '왜 그렇게 되었는가'에 대한 나의 생각이다.

## 좋은 코드가 필요한 이유

왜 프로그래머들은 변경하기 쉬운 코드를 '좋은 코드'로 여기는 것일까? 이는 프로그램이 자주 변경되어야 하기 때문인데 개발 단계에서 이런 변경의 원인은 대체로 '요구사항 변경'과 '분석 오류'에 기인한다.

'요구사항 변경'은 프로그래머가 어찌할 수 없다고 해도 무엇을 개발할 것인지를 신중하게 분석하고 설계하면 '분석 오류'를 줄일 수 있지 않을까?

그러나 대부분의 프로젝트가 이런 문제에 직면하고 있음을 보면 '분석 오류'를 줄이는 노력도 쉽지 않은 것 같다. 그도 그럴 것이 '요구사항 변경'이 발생하면 기존의 분석과 설계도 변경해야 하기 때문이다.

결국 '요구사항 변경'을 제어할 수 없는 상황에서 변경으로 인해 발생하는 문제를 최소화하는 전략을 세워야 하는데 그 결과물이 '좋은 코드'다.

소프트웨어와 비교해 보면, 건축물이나 자동차와 같은 실체가 있는 제품은 요구사항을 자주 변경하지 않는다. 소프트웨어 만큼 자주 변하는 분야는 음악이 있는데, 유명한 곡에 얼마나 많은 변형이 있는지 생각해 보면 이해가 갈 것이다.

그렇다면 왜 소프트웨어는 요구사항이 자주 변경될까? 이는 소프트웨어의 본질적인 특성 때문이다.
소프트웨어는 그 이름에서 유추할 수 있듯이 유연성이라는 본질적 특성을 가지고 있다. 많은 책들이 이를 유연성이라고 부르지만, 더 적절한 표현은 '무형'이라고 생각한다. 소프트웨어는 논리와 개념의 집합으로, 물리적 형태가 없는 무형의 산물이다. 이러한 특성은 소프트웨어를 유연하게 만들지만, 이 무형이라는 특성은 또한 그것을 구현하는 과정을 더 어렵게 만든다.

무슨 말이냐 하면 건축물이나 자동차와 같이 물리적 형태가 있는 제품은 미리 모델링하거나 미니어처를 만들어서 사용자에게 보여주고 검토할 수 있다. 하지만 무형인 소프트웨어는 그럴 수 없다. 구현해야 할 개념을 사용자가 이해할 수 있게 눈에 보이는 형태로 표현해야 하는데 그것이 어렵다. 그래서 개발이 진행될수록 사용자와 개발자 사이의 이해 차이가 생기고, 이로 인해 큰 변화를 겪게 된다.

사용자의 생각을 정확히 이해하고 이를 실체화하는 것은 어렵지만, 이보다 더 어려운 점은 사용자의 생각이 계속 변한다는 것이다. 사람의 생각은 창조적이어서 계속해서 새로운 아이디어가 떠오른다. 건물이나 자동차처럼 물리적 형태가 있는 제품은 변경이 어렵기 때문에 사용자의 생각이 바뀌어도 사용자는 그것을 바꿔달라는 요구를 하지 않는다. 하지만 소프트웨어는 언제든지 바꿀 수 있다는 환상이 있어서 출시 직전까지 요구사항 변경에 시달린다.

결국, 변화는 자연스러운 것이고, 그것을 받아들이고 대처하는 것이 프로그래머의 역할이다. 그렇기 때문에, 가능한 한 손쉽게 변경을 수용할 수 있는 코드를 작성하는 것이 중요하다.

> SI 프로젝트를 하게 되면 요구사항을 정의하는 담당자(갑)가 있다.\
> 프로그래머들은 담당자와 많은 커뮤니케이션을 통해서 분석하고 설계하고 검증한다.\
> 그리고 설계대로 열심히 구현하고 내부 테스트를 진행한다.\
> 그런데, 그 때까지 프로젝트에 관심이 없던 갑의 상사가 이렇게 바꾸면 좋겠다는 의견을 낸다.\
> 흔히 발생하는 이런 상황은 자연재해와 같아서 피할 수 있는 문제가 아니다.\
> 이런 자연재해가 아니라도 인간의 생각은 계속 변하기 때문에 요구사항의 변경은 필연적이고 분석과 설계의 반복은 불가피하다.

프로그램이 자주 변경되는 다른 이유는 소프트웨어의 복잡성 때문이다.
'Grady Booch'의 저서 'Object Oriented Analysis and Design with Applications'에서 이에 대한 통찰을 얻을 수 있다. 요약하면, 소프트웨어는 그 복잡성 때문에 완벽하게 한 번에 만들어내기 어렵다. 점진적으로 개선하면서 완성해 나가는 데, 그 과정에서 변경이 이루어지는 것이다.

> 산업용 소프트웨어 특징으로는 개발자 한 사람이 설계 부분까지 상세히 모두 알기에는 무척 까다롭다.\
> 비록 불가능하지는 않겠지만, 대충 말해 이 정도의 시스템 복잡도라면 인간이 처리하는 지적 능력을 초과한다.\
> 안된 일이지만 이런 복잡성은 대형 소프트웨어 시스템에서는 모두 나타나는 본질적 속성으로 보인다.\
> 본질이라는 말은 복잡성을 정복할 수는 있어도 복잡성 자체를 제거할 수는 없다는 뜻이다.

소프트웨어가 복잡한 이유 또한 소프트웨어의 유연성 때문인데, 유연하기 때문에 표준화가 어렵고 세세한 부분까지 직접 구현해야 하는 요구가 많기 때문에 복잡해진다.

## 운영환경의 변화와 좋은 코드

운영 환경의 변화로 인해 코드를 변경해야 하는 경우도 있다. 예를 들면:

- OS의 업그레이드로 인해 API가 바뀌는 경우.
- 외부 인증 서비스가 중단되거나 비용이 상승해 다른 서비스로 전환해야 하는 경우.
- 사용자가 증가하면서 성능 저하 문제가 발생하는 경우.
- 사용 중인 라이브러리에서 보안 취약점이 발견되거나 라이센스 정책이 변경되는 경우.

장기적으로 보면, 소프트웨어의 운영환경이 변화하는 주요한 원인 중 하나는 하드웨어의 발전이다. 하드웨어는 소프트웨어를 실행하는 '그릇'과도 같다. 하드웨어의 발전이 빠르면 소프트웨어의 발전도 빠르다.

예를 들어, CPU와 메모리의 발전에 따라 텍스트 기반의 OS에서 GUI 기반의 OS로 변화했고, CPU의 크기 축소로 스마트폰이 등장하면서 앱 개발이 활성화되었다. CPU 성능 향상이 한계에 다다르면서 이제는 8개의 코어가 기본이 되었고, 이에 따라 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화하였다. 통신 인프라의 발전에 따라 클라우드 컴퓨팅이 등장했으며, CPU와 메모리의 발전으로 가상화 기술도 발전하고 있다.

만약 VR이 대중화된다면 그에 맞는 새로운 인터페이스가 필요하게 될 것이고, SSD의 속도가 계속 향상된다면 메인 메모리의 개념이 사라질 수도 있다.

이처럼 하드웨어의 발전에 따라 새로운 플랫폼과 개념이 등장하고, 그에 따라 소프트웨어도 계속 변화해야 한다. 어느 쪽이든, 가능한 한 기존 코드를 활용하는 것이 효율적이기 때문에, 좋은 코드를 작성하는 것이 중요하다는 것을 잊지 말아야 한다.

이런 식으로 변화는 불가피하게 찾아오며, 기능 개선에 대한 요구 역시 끊임없이 이어진다.

## 좋은 코드를 위한 도구와 전략

이 글의 주제는 `좋은 코드`이지만, 여기서 이야기하는 '코드'는 단순히 'printf("hello world!")'와 같은 좁은 의미의 코드를 의미하지 않는다. 여기서 말하는 '코드'는 표준화된 인터페이스와 유연한 아키텍처 등 '변화에 대응하는 기술적인 방법 모두'를 포함한다.

그 중에서도 리팩토링은 좋은 시작점이다. 리팩토링은 현재 코드의 무엇이 문제이며 이를 어떻게 개선할 수 있는지에 대한 이야기이다. 이에 대한 자세한 내용은 `Martin Fowler`의 `Refactoring`을 추천한다.

변화에 대응하는 방법들 중 대표적인 것들을 아래에 나열해 보았다. 이는 전부가 아니며, 기준에 따라서는 더 많은 방법들이 존재할 수 있다. 중요한 것은 변화에 대응하기 위해서 다양한 방법들이 존재한다는 사실이다.

- 설계 방법: OOP, 디자인 패턴, Layered 아키텍처, MVC/MVVM, MSA 등
- 개발 도구: Java, .NET, React Native, Flutter, TypeORM, MyBatis, Docker/Kubernetes 등
- 개발 방법론: TDD, DDD, 애자일 등

위의 설계 방법과 도구들이 공통으로 가지고 있는 특징은 바로 '변화에 대응한다'는 점이다. 변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다. 이는 코드에도 마찬가지이며, 좋은 코드란 변화에 쉽게 적응하는 코드이다. 이런 코드의 특징은 의존성이 낮고 응집성이 높은 것이다. 그래서 패턴이나 아키텍처의 핵심은 규모만 다를 뿐, 의존성과 응집성에 대한 이야기이다.

변화에 대응하는 방법들에 대한 많은 서적들이 있다. 그 중 일부는 의존성과 응집성을 직접적으로 이야기하기도 하며, 그렇지 않더라도 모든 서적들은 결국 변화에 대한 이야기이다. 그리고 이 블로그에서도 좋은 코드, 그러니까 응집성과 의존성에 대한 이야기를 하려 한다.

![의존성/응집성](/assets/refs/cohesion-coupling.png)
그림1 - 의존성과 응집성
> 다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
> 그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 할 수 있다.

마지막으로, 위에 나열한 개발 방법과 도구들에 집착하는 경우를 종종 보게된다. 그러나 문제의 본질을 통찰하고 예측할 수 있다면, 대응하는 것은 비교적 쉽고 도구도 올바르게 사용할 수 있다. 반대로 도구에만 집착하면 오버엔지니어링이 될 수 있다. 도구는 수단이지 목적이 아님을 잊지 말아야 한다.

## 결론

React, NodeJS와 같은 응용 기술은 변화가 빠르기 때문에 한 프로그래머가 여러 영역에 걸쳐서 전문성을 유지하기 쉽지 않다. 반면에 패턴과 아키텍처와 같은 개발 이론의 지식은 쉽게 얻을 수 없지만, 얻게 되면 모든 분야에 유용하다. 설계 없는 개발은 있을 수 없는 일이다.

어떤 사람은 디자인 패턴을 공부하더라도 다른 프로그래머들이 이해하지 못하기 때문에 쓸모가 없다고 말한다. 그러나 시니어나 팀장이 되면 전체적인 틀을 잡고 주니어들에게 가이드를 제공하며 작업을 진행하게 된다. 이때 소프트웨어 공학에 능숙하다면 더 나은 가이드를 제공할 수 있다.

컴퓨터가 처음 개발되었을 때는 하드웨어 성능이 부족했지만, 지금은 하드웨어 성능이 충분하다. 그래서 소프트웨어는 성능 효율보다는 변경 효율에 중점을 두고 발전하고 있다. Docker나 크로스플랫폼과 같은 기술들이 이를 반영하고 있다. 이에 따라 현대의 좋은 코드란 변화에 잘 적응하는 코드이다.

끝으로, 지식만으로는 프로젝트를 완성할 수 없다. 나와 상대방을 아우르는 현명함이 필요하다. 그래서 이 블로그에서는 개발 방법론 뿐만 아니라, 여러 회사를 거치면서 어려웠던 경험들을 공유하려고 한다. 이 블로그가 Manner Code인 이유이다.
