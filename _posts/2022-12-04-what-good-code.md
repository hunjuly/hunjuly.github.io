---
layout: post
title: "1. 좋은 코드란 무엇인가?"
---

프로그래머라면 누구나 자신의 실력을 평가받고 싶어한다. 그러면 프로그래머의 실력을 어떻게 평가할 수 있을까? 알고리즘 기법의 활용, 빠른 기능 구현 능력, 능숙한 디버깅, 최신 기술에 대한 지식 등을 보면 어느 정도 실력을 파악할 수 있을 것이다.

그러나 프로그래머의 실력을 평가하는 척도는 이것만으로 충분할까? SDK를 활용하는 능력, 알고리즘 이해와 응용능력은 기본적인 기술 숙련도에 지나지 않는다. 그렇다면 주니어 프로그래머와 시니어 프로그래머 사이의 차이는 어떤 부분에서 나타날까?

내 생각에는 프로그래머의 실력은 '얼마나 좋은 코드를 작성할 수 있는가'에 크게 좌우된다. 여기서 주의해야 할 점은, 이는 프로그래머의 코딩 능력에만 초점을 맞춘 평가라는 것이다. 물론, 우수한 프로그래머는 코딩 능력뿐만 아니라 효과적인 커뮤니케이션 등도 함께 갖추어야 한다.

좋은 코드란 무엇일까? 이 질문에 대한 답은 상황과 사람마다 다르다. 좋은 코드의 정의는 주관적이며, 상황에 따라 변할 수 있기 때문이다. 하지만 대체로 프로그래머들 사이에는 '읽기 쉽고 변경하기 쉬운 코드'를 좋은 코드라고 인정하는 경향이 있다. 이는 코드를 변경하기 위해 코드를 읽는 것이 목적이기 때문이다. 그래서 좋은 코드의 정의를 '변경하기 쉬운 코드'로 간략하게 정의해 볼 수 있다.

이 글은 좋은 코드에 대한 내 생각을 정리한 것이다.

## 좋은 코드의 중요성

### 소프트웨어의 복잡성과 코드 품질

그렇다면 왜 프로그래머들은 변경하기 쉬운 코드를 '좋은 코드'로 여기는 것일까? 이는 소프트웨어, 즉 코드의 집합체가 자주 변경되어야 하기 때문이다. 이런 변경의 원인은 대체로 '사용자의 요구사항 변경'과 '분석 과정에서의 오류'에 기인한다. 또한, 운영 환경의 변화로 인해 코드를 변경해야 하는 경우도 있다. 예를 들면:

- OS의 업그레이드로 인해 API가 바뀌는 경우.
- 외부 인증 서비스가 중단되거나 비용이 상승해 다른 서비스로 전환해야 하는 경우.
- 사용자가 증가하면서 성능 저하 문제가 발생하는 경우.
- 사용 중인 라이브러리에서 보안 취약점이 발견되거나 라이센스 정책이 변경되는 경우.

이렇게 보면, 소프트웨어의 변경은 필연적이며, 기능 개선 요구도 끊임없이 나오게 된다. 이는 운영 환경의 변화를 막을 수 없는 것처럼, 요구사항의 변경도 어느 정도는 필연적인 것일 수 있다. 분석과 설계 단계에서 주의를 기울여도, 그에 따른 오류를 완전히 제거하는 것은 쉽지 않다.

> 요구사항 변경이 필연적인 몇 가지 유형이 있다.
> SI 프로젝트를 하게 되면 요구사항을 정의하는 담당자(갑)가 있다.
> 프로그래머들은 담당자와 많은 커뮤니케이션을 통해서 분석하고 설계하고 검증한다.
> 그리고 설계대로 열심히 구현하고 내부 테스트를 진행한다.
> 그런데, 그 때까지 프로젝트에 관심이 없던 갑의 상사(을)가 요구사항을 잘못 정의했다는 지적을 한다.
> 흔히 발생하는 이런 경우는 자연재해와 같아서 피할 수 있는 문제가 아니다.
> 이런 자연재해가 아니라도 인간의 생각은 계속 변하기 때문에 요구사항의 변경은 필연적이다.

대부분의 프로젝트가 이런 문제에 직면하고 있음을 보면, 이는 소프트웨어 개발의 일반적인 패턴이라고 볼 수 있다. 이런 상황에서는 문제를 최소화하는 전략을 세우는 것이 필요하다.

이와 비교해 보면, 건축물이나 자동차와 같은 실체가 있는 제품은 자주 변경하지 않는다. 자동차의 경우, 바퀴를 교체하거나 엔진을 개조할 수는 있지만 프레임 자체를 변경하는 것은 거의 고려하지 않는다. 소프트웨어만큼 자주 변하는 분야는 음악이 있는데, 유명한 곡이 얼마나 많이 변형되는지 생각해 보면 이해가 갈 것이다.

그렇다면 왜 소프트웨어는 자동차의 프레임에 해당하는 부분까지도 변경해야 할까? 'Grady Booch'의 저서 'Object Oriented Analysis and Design with Applications'에서 이에 대한 통찰을 얻을 수 있다. 요약하면, 이는 소프트웨어의 본질적인 특성인 '복잡성' 때문이라고 볼 수 있다. 즉, 소프트웨어는 그 복잡성 때문에 완벽하게 한 번에 만들어내기 어렵다. 점진적으로 개선하면서 완성해 나가는 과정에서 변경이 이루어지는 것이다.

> 산업용 소프트웨어 특징으로는 개발자 한 사람이 설계 부분까지 상세히 모두 알기에는 무척 까다롭다.
> 비록 불가능하지는 않겠지만, 대충 말해 이 정도의 시스템 복잡도라면 인간이 처리하는 지적 능력을 초과한다.
> 안된 일이지만 이런 복잡성은 대형 소프트웨어 시스템에서는 모두 나타나는 본질적 속성으로 보인다.
> 본질이라는 말은 복잡성을 정복할 수는 있어도 복잡성 자체를 제거할 수는 없다는 뜻이다.

그렇다면 소프트웨어의 복잡성 때문에 발생하는 빈번한 변경에 어떻게 대처해야 할까? 이를 위해선 소프트웨어의 또 다른 본질적 특성인 '유연성'을 이해하고 활용해야 한다.

### 소프트웨어의 유연성과 코드 품질

소프트웨어는 그 이름에서도 알 수 있듯이 유연성이라는 본질적 특성을 가지고 있다. 많은 책들이 이를 유연성이라고 부르지만, 더 적절한 표현은 '무형'이라고 생각한다. 소프트웨어는 논리와 개념의 집합으로, 물리적 형태가 없는 무형의 산물이다. 이러한 특성은 소프트웨어를 유연하게 만들지만, 이 유연성은 또한 그것을 구현하는 과정을 더 복잡하게 만든다.

건축물이나 자동차와 같이 물리적 형태가 있는 제품은 미리 모델링하거나 미니어처를 만들어서 사용자에게 보여주고 검토받을 수 있다. 하지만 소프트웨어는 그럴 수 없다. 구현해야 할 개념을 사용자가 이해할 수 있게 눈에 보이는 형태로 표현하는 것은 어렵다. 그러므로 개발이 진행될수록 사용자와 개발자 사이의 이해 차이가 생기고, 이로 인해 큰 변화를 겪게 된다.

사용자의 생각을 정확히 이해하고 그것을 문서로 작성하는 것이 어렵지만, 그보다 더 어려운 것은 사용자의 생각이 지속적으로 변한다는 것이다. 사람의 생각은 창조적이어서 계속해서 새로운 아이디어가 떠오르기 때문이다. 건물이나 자동차처럼 물리적 형태가 있는 제품은 사용자의 생각이 바뀌어도 그것을 물리적으로 바꾸는 것이 어렵기 때문에 크게 문제가 되지 않는다. 하지만 소프트웨어는 언제든지 바꿀 수 있다는 생각이 있어서, 출시 직전까지 요구사항 변경에 시달릴 수 있다.

결국, 변화는 자연스러운 것이고, 그것을 받아들이고 대처하는 것이 프로그래머의 역할이다. 그러므로 가능한 쉽게 변경을 수용할 수 있는 코드를 작성하는 것이 중요하다.

유연성과 복잡성은 소프트웨어의 본질적인 측면으로서 서로 밀접한 관련이 있습니다. 소프트웨어의 유연성은 변화를 가능하게 만드는 동시에 복잡성을 증가시키기도 합니다. 따라서 프로그래머들은 이 두 가지 측면을 모두 고려하여 코드를 작성해야 합니다. 유연성을 활용하여 변경을 수용하면서도, 이러한 변경이 코드의 복잡성을 과도하게 증가시키지 않도록 조절하는 것이 중요합니다.

### 하드웨어의 발전과 코드 진화

소프트웨어의 변화를 불러오는 또 다른 요인은 하드웨어의 발전이다. 하드웨어는 소프트웨어를 실행하는 '그릇'과도 같다. 하드웨어의 발전이 빠르면 소프트웨어의 발전도 빠르다.

예를 들어, CPU와 메모리의 발전에 따라 텍스트 기반의 OS에서 GUI 기반의 OS로 변화했고, CPU의 크기 축소로 스마트폰이 등장하면서 앱 개발이 활성화되었다. CPU 성능 향상이 한계에 다다르면서 이제는 8개의 코어가 기본이 되었고, 이에 따라 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화하였다. 통신 인프라의 발전에 따라 클라우드 컴퓨팅이 등장했으며, CPU와 메모리의 발전으로 가상화 기술도 발전하고 있다.

만약 VR이 대중화된다면 그에 맞는 새로운 인터페이스가 필요하게 될 것이고, SSD의 속도가 계속 향상된다면 메인 메모리의 개념이 사라질 수도 있다.

이처럼 하드웨어의 발전에 따라 새로운 플랫폼과 개념이 등장하고, 그에 따라 소프트웨어도 계속 변화해야 한다. 어느 쪽이든, 가능한 한 기존 코드를 활용하는 것이 효율적이기 때문에, 좋은 코드를 작성하는 것이 중요하다는 것을 잊지 말아야 한다.

## 좋은 코드를 위한 도구와 전략

이 글의 주제는 `좋은 코드`이지만, 여기서 이야기하는 '코드'는 단순히 `printf("hello world!")`와 같은 좁은 의미의 코드를 의미하지 않는다. 여기서 말하는 '코드'는 표준화된 인터페이스와 유연한 아키텍처 등 '변화에 대응하는 기술적인 방법 모두'를 포함한다.

그 중에서도 리팩토링은 좋은 시작점이다. 이는 현재 코드의 무엇이 문제이며 이를 어떻게 개선할 수 있는지에 대한 이야기이다. 이에 대한 자세한 내용은 `Martin Fowler`의 `Refactoring`을 추천한다.

변화에 대응하는 방법들 중 대표적인 것들을 아래에 나열해 보았다. 이는 전부가 아니며, 기준에 따라서는 더 많은 방법들이 존재할 수 있다. 중요한 것은 변화에 대응하기 위해서 다양한 방법들이 존재한다는 사실이다.

- 설계 방법: OOP, 디자인 패턴, Layered 아키텍처, MVC/MVVM, MSA 등
- 개발 도구: Java, .NET, React Native, Flutter, TypeORM, MyBatis, Docker/Kubernetes 등
- 개발 방법론: TDD, DDD, 애자일 등

위의 설계 방법과 도구들이 공통으로 가지고 있는 특징은 바로 '변화에 대응한다'는 점이다. 변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다. 이는 코드에도 마찬가지이며, 좋은 코드란 변화에 쉽게 적응하는 코드이다. 이런 코드의 특징은 의존성이 낮고 응집성이 높은 것이다. 그래서 패턴이나 아키텍처의 핵심은 규모만 다를 뿐, 의존성과 응집성에 대한 이야기이다.

변화에 대응하는 방법들에 대한 많은 서적들이 있다. 그 중 일부는 의존성과 응집성을 직접적으로 이야기하기도 하며, 그렇지 않더라도 모든 서적들은 결국 변화에 대한 이야기이다. 그리고 이 블로그에서는 좋은 코드, 그러니까 응집성과 의존성에 대한 이야기를 하려 한다.

![의존성/응집성](/assets/refs/cohesion-coupling.png)
그림1 - 의존성과 응집성
> 다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
> 그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 할 수 있다.

마지막으로, 많은 사람들이 위에 나열한 개발 방법과 도구들에 집착하는 것처럼 보일 수 있다. 그러나 문제의 본질을 통찰하고 예측할 수 있다면, 대응하는 것은 비교적 쉽고 도구도 올바르게 사용할 수 있다. 반대로 도구에만 집착하면 오버엔지니어링이 될 수 있다. 도구는 수단이지 목적이 아님을 잊지 말아야 한다.

## 결론

React, NodeJS와 같은 응용 기술은 변화가 빠르기 때문에 한 프로그래머가 여러 영역에 걸쳐서 전문성을 유지하기 쉽지 않다. 반면에 패턴과 아키텍처와 같은 개발 이론의 지식은 쉽게 얻을 수 없지만, 얻게 되면 모든 분야에 유용하다. 설계 없는 개발은 있을 수 없는 일이다.

어떤 사람은 디자인 패턴을 공부하더라도 다른 프로그래머들이 이해하지 못하기 때문에 쓸모가 없다고 말한다. 그러나 시니어나 팀장이 되면 전체적인 틀을 잡고 주니어들에게 가이드를 제공하며 작업을 진행하게 된다. 이때 소프트웨어 공학에 능숙하다면 더 나은 가이드를 제공할 수 있다.

컴퓨터가 처음 개발되었을 때는 하드웨어 성능이 부족했지만, 지금은 하드웨어 성능이 충분하다. 그래서 소프트웨어는 성능 효율보다는 변경 효율에 중점을 두고 발전하고 있다. Docker나 크로스플랫폼과 같은 기술들이 이를 반영하고 있다. 이에 따라 현대의 좋은 코드란 변화에 잘 적응하는 코드이다.

끝으로, 지식만으로는 프로젝트를 완성할 수 없다. 나와 상대방을 아

우르는 현명함이 필요하다. 그래서 이 블로그에서는 개발 방법론 뿐만 아니라, 여러 회사를 거치면서 어려웠던 경험들을 공유하려고 한다. 이 블로그가 Manner Code인 이유이다.
