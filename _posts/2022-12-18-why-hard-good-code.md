---
layout: post
title: "2. 좋은 코드의 어려움"
---

좋은 코드를 작성하고 싶지만 무엇이 좋은 코드이고 어떻게 하면 되는지 모르는 경우가 많다.\
널리 알려진 소스코드를 보면 어딘지 모르게 깔끔하고 읽기가 쉬운데 내가 작성한 코드는 아무리 노력해도 어설프다.\
그래서 '리팩토링'을 공부하고 '클린 코드' 같은 책도 읽어보지만 크게 도움이 되지 않는다.

좋은 코드를 향한 노력은 보통 아래의 순서로 진행이 된다.

1. 리팩토링을 학습, 코드가 조금 개선된다.
2. 디자인 패턴을 학습, 코드가 그럴듯해 보인다.
3. 유닛 테스트 작성, 프로젝트가 그럴듯해 보인다.

그리고 얼마 지나지 않아서 새로운 요구사항이 나타나면 아래의 순서로 좌절하게 된다.

1. 클래스를 유연하게 만들었다고 생각했다.\
   그러나 클래스가 새 요구사항을 수용하지 못해서 크게 변경하게 된다.
2. 클래스가 변경되면서 세심하게 작성한 테스트가 동작하지 않는다.\
   그러나 다시 작성하려니 많은 노력이 필요해서 그냥 삭제하게 된다.
3. 코드가 크게 변경되면서 리팩토링이 필요해졌다.\
   그러나 프로젝트의 진행이 더뎌서 다음으로 미룬다.

안타깝게도 많은 프로그래머들이 이런 실패를 몇 번 경험하면 좋은 코드에 대한 노력을 포기하고 좋은 코드를 책에서나 나오는 이상론으로 치부하게 된다.\
그러나 현대적인 개발 프레임워크들은 모두 테스트 자동화를 충실히 지원하고 있고 규모있는 오픈소스 프로젝트들 역시 테스트 코드의 비중이 높은 편이다.\
테스트를 언급하는 이유는 테스트가 잘 갖춰져 있으면 대체로 좋은 코드일 확률이 높은데, 좋은 코드가 아니면 테스트를 갖추기가 어렵기 때문이다.

좋은 코드가 실제하고 또 충분히 실용적이라면 우리는 왜 좋은 코드를 작성하는 것이 어려울까?\
크게 두 가지가 부족하기 때문인데 하나는 **객체지향의 이해**이고 다른 하나는 **분석과 설계**다.

## 객체지향의 이해

### 객체지향의 장점

객체지향에 대한 좋은 설명들은 이미 거장들의 책 속에 있어서 여기에서는 단순히 소개만 한다.\
다만, 몇 개의 단어를 '절차식'과 '객체지향'으로 통일했다.

객체지향을 사용해야 하는 이유와 장점은 아래와 같다.

> 경험에 비춰보면 객체지향을 우선 적용하는 것을 선호한다.\
> 이러한 접근 방법이 소프트웨어 시스템의 고유 복잡도를 정리하는 데 더 도옴을 주기 때문이다.\
> 이는 앞서 컴퓨터, 식물, 은하계, 대규모 사회 조직과 같이 다양하고 복잡한 시스템에서 복잡한 구성을 묘사하는 데 객체지향이 도움이 된 것과 마찬가지다.\
> 객체지향은 절차식과 비교해 보면 여러 중요한 장점이 있다.\
> 객체지향은 공통으로 사용하는 **메커니즘을 재사용**함으로써 전체 시스템을 작게 유지하기 때문에 시스템을 더 경제적으로 표현한다.\
> 또한 객체지향은 변화에 더 유연하게 대처할 수 있으며, 안정된 중간 형태를 기반으로 하기 때문에 시스템을 키워 나가기에 더 적합하다.\
> 실제로 객체지향으로 복잡한 소프트웨어 시스템을 구측하면 위험을 줄일 수 있다.\
> 이는 이미 증명된 작은 시스템으로부터 점진적으로 진화하면서 설계했기 때문이다.\
> 더 나아가 객체지향은 소프트웨어 고유의 복잡도에 직접 대응한다.\
> 광범위한 상태의 공간에서 관심을 분리해 사려 깊은 판단을 돕기 때문이다.
>
> Object Oriented Analysis and Design with Applications, 49p

여기에서 '메커니즘을 재사용'한다는 것은 절차식에서 함수를 공유하는 것과는 다르다.\
예를 들어, 입력을 받기 위해서 `interface InputStream`을 정의하고 필요에 따라서 `class BufferInputStream`나 `class FileInputStream`를 개발하는 것과 같다.\
이 때 `InputStream`을 제공하는 `BufferInputStream`이나 `FileInputStream`을 새로 개발할 뿐, `InputStream`을 사용하는 코드는 아무런 변경이 없다.\
이것은 stream을 입력받는 매커니즘을 재사용하는 것이다.

만약 절차식이고 `func InputStream(buffer)`이라는 함수가 있다면, 이것을 변경해서 `func InputStream(buffer, file)`이라는 함수로 만들어야 했을 것이다.\
Buffer와 File외에 Pipe 같은 다른 스트림이 추가되어야 한다면 어떨까?\
절차식 함수라면 전달인자(argument)가 점점 늘어나고 복잡해지거나 `func InputStream()`의 어딘가에 조건문이 들어가는 변경을 피하기가 어려울 것이다.

지금은 이 설명을 이해하기 어려워도 괜찮다. 나중에 더 자세히 설명할 기회가 있을 것이다.

### 객체지향과 절차식의 구조

<그림 1-3>과 <그림 1-4>는 절차식과 객체지향의 구조적 차이점을 보여준다.

<img src="/assets/refs/booch-46-seq.png">
<img src="/assets/refs/booch-47-oop.png">

<그림 1-3>의 함수로 이루어진 절차식 구조의 관계는 단순해서 흐름을 파악하기 쉽다.\
반면에 <그림 1-4>의 객체지향은 몇 개의 클래스가 서로 연결되어있어서 작업의 흐름을 파악하는 것이 어렵다.\
그러나 객체지향은 몇 개의 큰 덩어리들이 응집성 있게 구성되어 있어서 다른 기능을 구현할 때 재사용하기 쉽다.\
또 그런 특징들 때문에 변화의 영향이 다른 클래스에 미치지 않도록 해준다.

반면에 절차식 구조는 작은 함수 정도만 재활용 가능한데,\
만약에 `Update file`과 같은 큰 함수를 무리해서 재사용 하려고 하면 함수를 호출할 때 인자(argument)가 늘어나고 점점 복잡해지게 될 것이다.\
예컨대 `reformat`함수를 호출하는데 `ext4`나 `ntfs`등을 선택하고 싶다면 어떻게 해야 할까?\
`reformat`까지 이르는 세 개의 함수(`Update file`, `get formatted update`, `reformat`) 모두 `ext4`를 인자로 받아야 한다.\
또한 `reformat`에는 fileSystem을 판별하는 조건문이 추가될 것이다.

### 객체지향의 어려움

객체지향이 이렇게 많은 장점이 있음에도 불구하고 실제로 객체지향을 제대로 이해하는 프로그래머는 많지 않다.\
대부분은 처음 프로그래밍을 학습할 때 1부터 10까지 출력하는 간단한 함수로 시작해서 자연스럽게 절차식 프로그래밍에 익숙해지는데 그래디 부치는 객체지향과 절차식은 근본부터 다르다고 했다.\
이것이 절차식에 익숙한 프로그래머들이 객체지향을 이해하기 어려운 이유일 것이다.

> 객체지향은 기존 절차식 설계와는 근본부터 다르다.\
> 분해할 때 사고 방식도 전혀 다르다.\
> 그 결과로 나온 소프트웨어 아키텍처는 구조적 설계 문화 영역과는 멀리 떨어져 있다.
>
> Object Oriented Analysis and Design with Applications, 57p

어떻게 하면 객체지향을 이해할 수 있을까?\
마틴 파울러는 객체지향 프로젝트에서 얼마간 일해야 한다고 한다.\
그러나 객체지향을 제대로 이해하는 프로그래머가 많지 않아서 객체지향 환경을 찾는 것이 쉽지 않다.\
이것이 이 블로그의 주된 목적인데 이론과 실제 코딩을 통해서 객체지향을 포함하는 좋은 코드를 널리 알리는 것이다.

> 이와 같은 형태는 긴 프로시저에 익숙한 사람들에게는 아주 혼란스러운 것이다.\
> 하지만 이런 변화가 객체 지향으로의 패러다임 전환의 핵심이다.\
> 이것은 가르치기는 매우 어려운 것이다.\
> 제대로 이해하려면 분산 제어를 아주 많이 사용하는 객체 지향 환경에서 얼마간 일하는 수밖에 없는 것 같다.\
> 분산 제어를 이해하는 순간, 갑자기 "아 그렇구나." 라고 느끼게 된다고 많은 사람들이 말한다.\
> 그 순간부터 뇌의 구조가 바뀌어서 분산형 제어가 훨씬 쉽다고 생각하기 시작한다.
>
> UML Distilled, 68p

마틴 파울러가 이야기하는 뇌의 구조가 바뀌는 순간이 나에게도 있었다.\
어떻게 하면 아래의 코드를 개선할 수 있을까를 고민하다가 객체지향의 기본을 깨닫게 됐다.

<!-- switch나 if 같은 조건문은 절차식의 특징인데 아래 코드가 그 전형이다. -->

```typescript
switch (lang) {
  case "korean":
    "안녕";
    break;
  case "english":
    "hello";
    break;
  default:
    "unknown";
    break;
}
```

이 코드의 문제는 언어 별로 다르게 동작해야 하는 모든 곳에 이런 조건문이 생긴다는 것이다.\
이런 상황에서 새로운 언어가 추가되면 여러 소스코드를 찾아가면서 하나씩 추가해야 한다.

어떻게 하면 이 문제를 개선할 수 있을까?\
아래의 코드는 언어를 클래스로 나타냈다.\
이제 새로운 언어가 추가돼도 그에 해당하는 클래스를 개발하기만 하면 된다.\
클래스를 사용하는 쪽에서는 `interface Language`만 알면 되고 그것이 Korean인지 English인지는 신경쓰지 않는다.\
조건문을 사용하지 않아도 되는 것이다.

```typescript
interface Language {
  hello(): string;
}

class Korean : Language {
  public hello() {
    return "안녕";
  }
}

class English : Language {
  public hello() {
    return "hello";
  }
}

const language = new Korean();
language.hello();
```

이 즈음의 나는 '디자인 패턴' 책을 읽어도 이해가 되지 않고 답답함을 느끼고 있었다.\
그러나 이 아이디어를 떠올린 그 순간, 고민하고 있던 모든 것들이 하나로 연결되고 이해가 됐다.\
그 순간의 기쁨과 감동은 며칠 동안 계속됐는데 많은 프로그래머들이 나와 같은 경험을 했으면 좋겠다.

### 객체지향과 개발 방법

지금까지 언급한 객체지향의 장점 때문에 현대적인 개발 방법의 근간에는 객체지향이 있다.\
그래서 객체지향을 모르면 다양한 개발 방법을 이해하기가 쉽지 않고 규모있는 소프트웨어 개발이 어렵다.

예를 들면,

1. 테스트 자동화의 상당 부분은 의존 주입(Dependency Injection)을 사용한다.
1. 의존 주입은 디자인 패턴의 '전략 패턴'에 해당한다.
1. 디자인 패턴은 객체지향 설계에 기반한다.

그 외에도,

- MSA(Micro Service Architecture)는 디자인 패턴 중 '옵저버'에 해당한다.
- MVC(Model-View-Controller)나 MVVM(Model-View-ViewModel)은 세 개의 큰 객체로 볼 수 있다.
- 애자일 방법론은 짧은 개발주기가 특징인데 변화에 유연하게 대처할 수 있는 객체지향과 잘 맞는다.

이와 같이 객체지향을 잘 이해하면 기본적인 소프트웨어 설계 능력을 갖춘 것이다.\
거기에 더 많은 노력으로 다양한 디자인패턴과 TDD 같은 개발 방법까지 습득했다면 좋은 코드를 작성할 수 있지 않을까?

그러나,

- 많은 프로젝트가 MSA를 도입하고 후회한다.
- 디자인패턴을 적극적으로 적용한 코드가 오히려 변화에 취약한 코드가 된다.
- 작성한 '유닛 테스트(Unit Test)'는 얼마 지나지 않아서 무효화 되고 결국 삭제하게 된다.

이런 문제들을 극복하기 위해서 더 많은 설계와 아키텍쳐에 관한 책을 읽어보지만 효과를 보기는 어렵다.\
객체지향이 현대적인 개발 방법의 근간임에도 불구하고 그런 개발 방법을 적용하기 힘든 이유는 무엇일까?\
분석 능력이 부족하기 때문이다.

### 분석과 설계

요구사항 분석은 기획자와 디자이너의 요구를 충실히 반영하면 되니까 누구나 쉽게 할 수 있을 것 같다.\
A버튼을 누르면 화면B가 나오고 사용자의 상태에 따라서 화면이 어떻게 달라지는 등의 어떻게 보면 지루한 작업이다.

> 외교부 일화
> 문서를 다루는 프로젝트에서 문서의 개념이 바뀌는 것은 큰 변화다
> 만약 문서를 하나로 분석하고 테스트를 작성했다면 API가 변경되면서 그에 따르는 테스트도 모두 변경되어야 한다.
> 만약 분리하는 것이 부담스러워서 피하려고 한다면 코드 곳곳에 if-else가 넘쳐나게 될 것이고 지옥으로 가는 문이 열리게 된다.

변경될 수 있는 부분을 세심하게 고려해서 설계해야 한다.
그러나 무엇이 변경될 수 있을지를 예측하는 것은 날씨 예보 만큼이나 어렵다.
많은 변수가 있고 언제 변경될지 알 수 없다.
그런 것을 대비하는 것은 비용이 크다.

그러나 도메인의 개념을 충실히 구현하면 어떤 변화가 있더라도 대응하기 쉽다.
애초에 도메인의 개념 자체가 바뀌는 일은 많지 않기 때문이다.

구현에 익숙해져있기 때문에 구현을 우선시해서 설계를 구현에 맞추는 실수를 한다.
이것은 습관이기 때문에 머리로 알고 있어도 어느 순간 그렇게 된다.

여기까지가 내가 겪은 소프트웨어 개발에 필요한 마지막 뇌수술이다.

분석을 기반으로 설계와 구현이 되어야 한다.
그러나 효율성을 이유로 구현과 적당히 타협한 분석이 돼버린다.
이렇게 하면 전제가 흔들리기 때문에 요구사항이 변경되면 그것을 수용할 수 없게 된다.

요구사항은 계속 변경되고
유닛 테스트를 작성할 때 발생하는 문제도 크게 개선되지 않는다.

## 결론

<!-- 분석은 개발 프로세스의 가장 처음에 이루어지면서 이해하기에는 가장 어렵다. -->

소프트웨어 개발 프로세스는 분석 -> 설계 -> 구현 -> 테스트 순서로 진행된다.
그러나 구현을 하지 못하면 설계를 못하고 설계를 못하면 분석을 못한다.
그래서 보통은 구현 -> 설계 -> 분석의 순서로 학습을 하게된다.
문제는 분석 단계에 이르기 전에는 공부하는 많은 개발 방법을 제대로 적용하기 어렵다는 것이다.
그 과정에서 많은 프로그래머들이 포기하게 되고 분석까지 도달하지 못한다.
분석까지 되어야 재미있는 코딩을 할 수 있는데 아쉽다.

분석과 설계 스타일은 사람마다 다르다고 한다. 어느 정도는 맞는 말이다.\
그러나 올바른 결정을 할 수 없을 때 스타일로 치부하는 경향이 있다.\
분석과 설계는 주관적이고 추상적이기 때문에 소프트웨어의 근본 개념까지 쫓아가게 된다.\
소프트웨어 공학 이론은 실무에서 쓸모없는 것으로 치부하는 프로그래머가 많다.\
그러나 실력이 쌓이고 쌓이면 언젠가는 소프트웨어의 근본과 철학에 대한 고민을 하게 될 것이다.
