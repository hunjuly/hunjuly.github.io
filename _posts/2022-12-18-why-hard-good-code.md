---
layout: post
title: "2. 좋은 코드의 어려움"
---
<!--
현재 상황 - 좋은 코드를 작성하고 싶지만 어떻게 해야 할지 모른다. 리팩토링에서 말하는 규칙을 준수하며 이름 짓기가 힘들다.
원인이 무엇인가?  - 리팩토링/OOP/테스트/설계/분석까지 올라가지 못했다. 분석 단계가 제대로 되지 않으면 그 이하는 계속 흔들린다.
어떻게 해야 하는가? - 분석부터 제대로
 -->
좋은 코드를 작성하고 싶지만 무엇이 좋은 코드이고 어떻게 하면 되는지 모르는 경우가 많다.\
널리 알려진 소스코드를 보면 어딘지 모르게 깔끔하고 읽기가 쉬운데 내가 작성한 코드는 아무리 노력해도 어설프다.\
그래서 `리팩토링`을 공부하고 `클린코드` 같은 책도 읽어보지만 크게 도움이 되지 않는다.

좋은 코드를 향한 노력은 보통 아래의 순서로 진행이 된다.

1. 리팩토링을 학습, 코드가 조금 개선된다.
2. 디자인 패턴을 학습, 코드가 그럴듯해 보인다.
3. 유닛 테스트 작성, 프로젝트가 그럴듯해 보인다.

그리고 얼마 지나지 않아서 새로운 요구사항이 나타나면 아래의 순서로 좌절하게 된다.

1. 유연하게 만들었다고 생각한 클래스가 새 요구사항을 수용하지 못해서 크게 변경하게 된다.
2. 클래스가 변경되면서 세심하게 작성한 테스트가 동작하지 않는다.\
다시 작성하려니 많은 노력이 필요해서 그냥 삭제하게 된다.
3. 코드가 크게 변경되면서 리팩토링이 필요해졌다.\
그러나 프로젝트의 진행이 더뎌서 다음으로 미룬다.

안타깝게도 많은 프로그래머들이 이런 실패를 몇 번 경험하면 좋은 코드에 대한 노력을 포기하고 좋은 코드를 책에서나 나오는 이상론으로 치부하게 된다.\
그러나 현대적인 개발 프레임워크들은 모두 테스트 자동화를 충실히 지원하고 있고 규모있는 오픈소스 프로젝트들 역시 테스트 코드의 비중이 높은 편이다.\
테스트를 언급하는 이유는 테스트가 잘 갖춰져 있으면 대체로 좋은 코드일 확률이 높은데, 좋은 코드가 아니면 테스트를 갖추기가 어렵기 때문이다.

좋은 코드가 실제하고 또 충분히 실용적이라라면 우리는 왜 좋은 코드를 작성하는 것이 어려울까?

1. 객체지향에 익숙하지 않음
2. 분석과 설계에 익숙하지 않음


### 객체지향의 어려움

객체지향에 대한 좋은 설명들은 이미 거장들의 책에 있어서 여기에서는 단순히 소개만 한다.

> OOADA = 그래디 부치, Object Oriented Analysis and Design with Applications

#### 객체지향의 장점(OOADA, 49p)
경험에 비춰보면 객체지향 관점을 우선 적용하는 것을 선호한다.\
이러한 접근 방법이 소프트웨어 시스템의 고유 복잡도를 정리하는 데 더 도옴을 주기 때문이다.\
이는 앞서 컴퓨터, 식물, 은하계, 대규모 사회 조직과 같이 다양하고 복잡한 시스템에서 복잡한 구성을 묘사하는 데 객체지향 접근법이 도움이 된 것과 마찬가지다.\
객체지향 분해는 알고리즘 분해와 비교해 보면 여러 중요한 장점이 있다. 객체지향 분해는 공통으로 사용하는 메커니즘을 재사용함으로써 전체 시스템을 작게 유지하기 때문에 시스템을 더 경제적으로 표현한다.\
또한 객체지향 시스템은 변화에 더 유연하게 대처할 수 있으며, 안정된 중간 형태를 기반으로 하기 때문에 시스템을 키워 나가기에 더 적합하다.\
실제로 객체지향 분해로 복잡한 소프트웨어 시스템을 구측하면 위험을 줄일 수 있다.\
이는 이미 증명된 작은 시스템으로부터 점진적으로 진화하면서 설계했기 때문이다.\
더 나아가 객체지향 분해는 소프트웨어 고유의 복잡도에 직접 대응한다.\
광범위한 상태의 공간에서 관심을 분리해 사려 깊은 판단을 돕기 때문이다.

요약하자면 객체지향 방법이 좋다는 것이다.
객체지향을 이해하는 것이 왜 어려울까?
우리는 절차식 프로그래밍에 익숙해져있다.

#### 구조적 설계와는 근본부터 다르다(OOADA, 57p)
객체지향 기슬은 공학을 토대로 튼튼한 기초 위에 세워졌으며, 총칭해 '개발용 객체 모델' 또는 단순히 '객체모델'이라고 한다.\
객체모델에는 추상화와 캡슐화, 모듈화, 계층, 타입, 병렬, 영속성 등 원리가 들어 있다.\
개별로 보면 어느 것 하나 새로울 것은 없다.\
객체모델에서 중시하는 점은 이러한 요소를 함께 모아 시너지 효과를 내는 일이다.\
객체지향 분석 설계는 기존 구조적 설계와는 근본부터 다르다.\
분해할 때 사고 방식도 전혀 다르다.\
그 결과로 나온 소프트웨어 아키텍처는 구조적 설계 문화 영역과는 멀리 떨어져 있다.

#### 마틴 파울러, UML Distilled, 68p
두 교류 다이어그램이 아주 다른 형식을 가지고 있다는 것이다.\
그럼 4.1은 중앙 집중형 제어(centralized control)로서 한 참가자가 거의 모든 처리를 하고 다른 참가자들은 데이터를 제공한다.\
그림 4.2는 분산 제어(distributed control)를 사용하므로 처리 작업이 여러 참가자에게 분산되어 각각의 참가자는 전체 알고리즘외 작은 부분만 수행한다.\
두 형식 모두 장단점이 있다. 대부분의 사람둘(특히 객체를 처옴 접하는 사 람들)은 중앙 집중형 제어에 익숙하다.\
여러 가지 면에서 중앙 집중형 제어는 모든 처리가 한 곳에서 일어나므로 단순하다. 반면 분산 제어는 프로그램을 이 해하려면 객체둘을 따라다녀야 한다.\
하지만 필자 같은 객체 광신도들은 분산 제어를 훨씬 더 선호한다.\
좋은 설 계외 목표 중 하나는 변경외 영향을 최소화하는 것이다.\
데이터와 그 데이터에 접근하는 행동은 함께 번경되는 경우가 많다.\
따라서 데이터와 그 데이터를 사 용하는 행동을 한 곳에 놓는 것이 객체 지향 설계의 첫 번째 규칙이다.\
게다가 분산 제어를 사용하면 조건문 대신 다형성을 사용할 수 있는 기희가 더 많이 생긴다.\
만약 제품의 가격을 걸정하는 알고리즘이 제품의 형태마다 다 르다면, 분산 제어 방식은 Product의 하위 클래스를 이용하여 이런 다른 알고 리즘을 해결할 수 있도록 헤 준다.\
보통 객체 지향 형식에서는 작은 메소드를 많이 가진 작은 객체를 많이 사 용하며, 이것은 재정의(override)와 변형(variation)에 필요한 많은 접점(plug point)을 제공해 준다.\
이와 같은 형태는 긴 프로시저에 익숙한 사람들에게는 아주 혼란스러운 것이다.\
하지만 이런 변화가 객체 지향으로의 패러다임 전환의 핵심이다.\
이것은 가르처기는 매우 어려운 것이다.\
제대로 이해하려면 분산 제어를 아주 많이 사용하는 객체 지향 환경에서 얼마간 일하는 수밖에 없는 것 같다.\
분산 제어를 이해하는 순간, 갑자기 "아 그렇구나." 라고 느끼게 된다고 많은 사람들이 말한다.\
그 순간부터 뇌의 구조가 바뀌어서 비중앙 집중형 제어가 훨씬 쉽다고 생각하기 시작한다.


이런 어려움을 극복하고 OOP를 이해하면 디자인패턴에도 쉽게 익숙해질 수 있다.
소프트웨어를 설계하기 위한 기본은 갖췄는데 왜 안 될까? 왜 계속 변경될까?

분석과 설계 스타일은 사람마다 다르다고 한다. 어느 정도는 맞는 말이다.
그러나 올바른 결정을 할 수 없을 때 스타일로 치부하는 경향이 있다.
분석과 설계는 주관적이고 추상적이기 때문에 소프트웨어의 근본 개념까지 쫓아가게 된다.
소프트웨어 공학 이론은 실무에서 쓸모없는 것으로 치부하는 프로그래머가 많다.
그러나 실력이 쌓이고 쌓이면 언젠가는 소프트웨어의 근본과 철학에 대한 고민을 하게 될 것이다.


### 좋은 함수의 어려움

함수를 작성하기 어렵다. 특히 이름 짓기가 어렵다.
assert try/catch를 적절히 사용해서 함수를 깔끔하게 만들 수는 있다.
그러나 함수가 변경되는 것을 피할 수는 없다.
그래도 함수는 비교적 쉬운 편인데 영향을 미치는 범위가 작기 때문이다.
클래스가 되면 더 많은 영향을 주고 모듈은 더더 많은 영향을 준다.
영향을 많이 주는 만큼 변화에 취약하기 마련이다.

이름이 길어지는 것은 함수가 하는 일이 명확하지 않아서다.
이것은 두 가지가 있는데 함수가 하는 일이 많거나 함수를 만든 프로그래머가 함수가 무슨 일을 하는지 제대로 파악하지 못해서다.
이 문제를 해결하려면 결국 클래스를 찾게 된다.
이름을 명확하게 하기 위해서 함수를 작게 만들면 너무 많은 함수가 만들어지는 것은 아닐까?
그래서 클래스를 찾게 된다.

### 클래스
리팩토링에서 소개하는 것은 지극히 기술적인 부분만 다룬다.
그런데 함수를 계속 변경하게 되는 것이 리팩토링의 기술이 부족해서일까?
함수의 인자값이 계속 바뀐다. (예제 고민하자)
이런 문제를 단순히 리팩토링으로 해결할 수는 없다.

그렇다면 OOP를 열심히 공부하고 SOLID원칙에 충실하면 좋아질까?
SOLID는 클래스 설계 지침일 뿐이다.
OOP는 익숙하고 SOLID에 충실하다면 변화에 잘 적응하는 좋은 코드를 만들 수 있을까?
답은 아니오다.
물론 그런 기술적인 지식들이 어느 정도 도움은 된다. 그러나 설계나 구현만으로는 좋은 코드를 작성할 수 없다.
변화에 대응하기 위해서는 분석이 제대로 이루어져야 한다.
이름 짓기가 힘들고 그래도 명확하게 이름을 지으려고 하니 이름이 길어진다. 함수나 변수 마찬가지다.
이것 또한 분석이 제대로 되지 않은 것이다. 이 함수가 무엇을 하는가에 대한 분석이 부족한 것이다.

말하고자 하는 것은 이미 나왔다. 좋은 코드를 작성하기 어려운 가장 근본적인 이유는 분석이 제대로 되지 않아서다.
왜 그럴까?
이것은 소프트웨어의 본질적 특성 때문인데 요구사항은 추상적이고 개념적이다.
프로그래머는 무언가부터 구체화를 시작해서 거기에 살을 붙여나가게 되는데 요구사항을 구체화 하기 어려운 것이다.
그래서 가장 구체화 하기 쉬운 DB나 로우레벨에 가까운 코드를 먼저 작성하게 되는데 이러면 정확한 분석과 점점 멀어지게 된다.
코드에 무언가 문제를 느껴서 개선해 보려고 하지만 분석에서 멀어진 상태로는 어떻게 해도 개선이 안 된다.
분석이 틀리면 그것을 기반으로 하는 설계와 구현이 모두 틀려지기 때문이다.
이름 짓기가 어려운 것도 분석을 구체적으로 하지 않아서 발생한다.
이러면 함수나 클래스가 구체적으로 어떤 일을 해야 하는지 나타낼 수가 없어진다.
물론 대략적으로 두리뭉실하게 어느정도 알 수는 있다. 그러나 어느 정도의 분석과 구체적인 분석은 0과 1 만큼의 차이가 있다.
이렇게 중요한 분석인데 분석까지 생각이 미치기에는 너무 먼 거리이다 보니 좋은 코드가 특히 어려워진다.
이것은 분석을 구체화 할 수 있기 전까지 계속되는 문제다. 그런데 요구사항 구체화가 쉽지 않다. UML 메뉴얼을 읽는다고 전부는 아니다.

### 1. OOP와 패턴을 이해하기 어려운 이유

무엇이 어떻게 변할 것인지 파악되지 않아서다.

1. 기초 서적에서 제시하는 예시는 자동차, 사과와 같은 일반적인 사물이다. 그렇다 보니 형태가 있는 사물에 대해서만 객체로 해석하려는 경향이 있다. 그러나 시간, 약속, 건강상태 등도 모두 객체다.

1. 사실 함수 하나를 디자인 하는 것도 쉽지 않다. params로 user를 받을 것인가? user.id를 받을 것인가? 등등 선택의 기준은 무엇이 어떻게 변할 것인지 예측하기에 달렸다.\
그런 예측은 전체 구조에 영향을 줄 수 있다. 함수와 호출자 외에 전체적인 구조에 따라 달라진다.

> 같은 구역이면 user 다른 구역이면 userID

문제를 인식해야 필요성을 느끼고 해결책으로 객체지향적인 생각을 하게 되는데, 그렇지 못하기 때문에 OOP로 사고하는 것이 어렵다.
코드의 일부분만을 보고 그것이 전체에 미칠 영향을 파악할 수 있어야 한다. 이것은 많은 경험과 학습이 필요하다.

다음의 코드에서 어떤 문제가 있을 수 있을까?

```typescript
switch (lang) {
  case "kor":
    "안녕";
    break;
  case "eng":
    "hello";
    break;
  default:
    "unknown";
    break;
}
```

어떻게 하면 해결할 수 있을까?

```typescript
interface Country {
  hello(): string;
}

class KOR {
  public hello() {
    return "안녕";
  }
}

class ENG {
  public hello() {
    return "hello";
  }
}

const country = new KOR();
country.hello();
```

문제에 따른 해결책에 차이는 있겠지만 다른 패턴도 의존성/응집성에 대한 이야기다.

### 2. 테스트는 어렵다.

패턴에 익숙하기만 할 뿐이다. 코드 작성 중에 전략패턴과 같은 다양한 패턴을 익숙하게 구현할 수는 있지만 그것이 설계는 아니다.
설계 없이 이렇게 저렇게 바꿔가며 구현하는 중에 사용하는 도구 중에 하나일 뿐이다.
혹은 그것이 설계라고 한다면 적어도 요구사항을 분석하는 능력이 부족한 것이다.

아키텍쳐에 대한 더 많은 이해가 필요하다.
모듈로 나누고 레이어로 나누고 어느 범위까지 테스트를 할 것인가 등등.
유닛테스트라고 해서 정확하게 함수 하나만 테스트 하는 것이 아니다.

레이어드 아키텍쳐에 대한 이해. 상위 레이어에 대한 이해.

사족->사실 패턴도 유사하다, 무엇이 적절한 패턴인지 판단하려면 더 상위의/다른 객체의/환경 분석이 필요하다.

요구사항을 먼저 구체화 할 수 있어야 한다.

이것이 어렵기 때문에 DB먼저 설계하는 상향식 개발을 하게된다.

그런데 요즘은 orm을 사용해서 DB를 직접 사용하는 것을 피한다.

> 아포스티유 프로젝트에서 유사한 형식의 두 종류 문서가 있었다. 기존 구현된 DB는 하나로 관리하고 있었고 두 종류로 나누는 것은 번잡하게 느껴졌다. 그러나 내용이 유사하다 하더라도 두 개의 개별적인 문서다. 우연히 내용이 비슷하다고 해서 이것을 하나의 문서로 취급하면 나중에 기능이 확장될 때 문제가 될 수 있다.
> 실제로도 그랬다. 다행히 db는 하나로 관리해도 service api는 두 종류로 구분해서 문제가 크게 번지지는 않았다.
> 상위 레이어 혹은 분석에서 시작하는 것이 아니라 분석과 구현 단계의 구분없이 개발이 진행되면 흔히 발생한다.
> 이런 통찰력이 없으면 분석이 제대로 되지 않고 설계와 구현까지 두루 영향을 미친다.

### 3. 그러나 요구사항 구체화는 어렵다.

눈에 보이지 않는 무형의 논리와 개념을 체계적으로 시각화 하는 것은 원래 어려움. 건축은 그림으로 그리고 규격화도 되어있다.
그래서 프로그래머들은 습관적으로 DB부터 정의한다. 당장 눈에 보이고 동작하기 때문이다.
그러나 이런 상향식 설계는 결국 도메인과 구현의 불일치에 도달하게 된다.

설계의 중요성이 여기서 드러난다. 추상적 개념을 분석하고 눈에 보이는 문서로 표현할 수 있어야 한다.
대표적으로 UML이 있겠으나 형식은 상관없다.
21세기 초, 우리나라에서는 이 UML이 유행했었고 그렇게 지나갔다.
왜 그랬을까?
분석을 구체적으로 표현하지 못한다. 분석을 기반으로 설계를 해야 하는데 Layerd arch. 같은 개념의 이해 이전에 제대로 된 분석 문서가 없는 것이다.
어떻게 하면 분석한 내용을 UML같은 도구를 사용해서 문서로 표현할 수 있을까?

분석 -> 설계 -> 구현 -> 테스트의 반복인데 시작이 어렵다.

1. 분석은 어떻게 하는가? 어떻게 구체화 할 수 있는가? 누가/무엇을 하는지부터 시작해라. Use Case, Activity
   1. 예외 : 익숙하지 않은 기술을 사용하는 경우 연구와 개발을 병행하게 된다. 이런 경우에는 설계 후 구현이 힘들다.
      꼭 기술이 아니라도 요구사항 자체가 확정적이지 않은 경우가 있다.

### 4. 설계는 어렵다


### 결론 - 프로그래머는 왜 변화에 대응하기 어려운가.

하향식 개발을 지향해야 제대로 할 수 있다. 그러나 많은 것을 이해하고 경험하지 못하면 구체화 하기 어렵기 때문에 상향식을 추구하게 된다.
할 수 있는 것은 상향식이고 해야 하는 것은 하향식이다. 그 간극 만큼이나 개발방법론 등이 비현실적으로 느껴지게 된다.
여기서 얘기하려는 것은 그 간격을 매울 수 있는 기회가 되길 바란다.

개발환경도 큰 영향을 미치는데 보통은 쉬운 모듈은 주니어가 개발하고 좀 어렵다 싶은 것은 시니어가 개발한다.
그러다 보니 눈에 보이는 기능부터 만들게 되고 분석은 뒷전으로 밀려난다.
시니어가 분석과 설계를 해서 주니어에게 전달하면 어려움은 크게 해소될 수 있다.

그리고 좋은 코드는 단계적으로 완성되지 않는다.
무슨 말이냐 하면 리팩토링을 학습하면 10% 좋아지고 디자인패턴을 학습하면 또 10% 좋아지고 이렇게 되지 않는다.

리팩토링, 디자인패턴, TDD, DDD, UML설계, 결국은 분석
난 위의 순서로 학습을 했다 그러나 완전한 이해를 하지 못하더라도 DDD를 우선적으로 학습해야 할까?
DDD를 먼저 읽으면 지나친 이상론으로 보일지 모른다.
정답은 없으나 패턴/TDD/DDD에 대한 충분한 이해와 경험이 필요하다.
