---
layout: post
title: "2. 좋은 코드의 어려움"
---
<!--
현재 상황 - 좋은 코드를 작성하고 싶지만 어떻게 해야 할지 모른다. 리팩토링에서 말하는 규칙을 준수하며 이름 짓기가 힘들다.
원인이 무엇인가?  - 리팩토링/OOP/테스트/설계/분석까지 올라가지 못했다. 분석 단계가 제대로 되지 않으면 그 이하는 계속 흔들린다.
어떻게 해야 하는가? - 분석부터 제대로
 -->
좋은 코드를 작성하고 싶지만 무엇이 좋은 코드이고 어떻게 하면 되는지 모르는 경우가 많다.\
널리 알려진 소스코드를 보면 어딘지 모르게 깔끔하고 읽기가 쉬운데 내가 작성한 코드는 아무리 노력해도 어설프다.\
그래서 `리팩토링`을 공부하고 `클린코드` 같은 책도 읽어보지만 크게 도움이 되지 않는다.

좋은 코드를 향한 노력은 보통 아래의 순서로 진행이 된다.

1. 리팩토링을 학습, 코드가 조금 개선된다.
2. 디자인 패턴을 학습, 코드가 그럴듯해 보인다.
3. 유닛 테스트 작성, 프로젝트가 그럴듯해 보인다.

그리고 얼마 지나지 않아서 새로운 요구사항이 나타나면 아래의 순서로 좌절하게 된다.

1. 심혈을 기울여서 유연하게 만들었다고 생각한 클래스가 새 요구사항을 수용하지 못해서 크게 변경하게 된다.
2. 클래스가 변경되면서 세심하게 작성한 테스트가 동작하지 않는다.\
다시 작성하려니 많은 노력이 필요해서 그냥 삭제하게 된다.
3. 코드가 크게 변경되면서 리팩토링이 필요해졌다.\
그러나 프로젝트의 진행이 더뎌서 다음으로 미룬다.

안타깝게도 몇 번 이런 실패를 경험하면 프로그래머들은 보통 좋은 코드에 대한 노력을 포기하고 좋은 코드는 책에서나 나오는 이상론으로 취급하게 된다.\
그러나 이상론으로 치부하기에는 현대적인 개발 프레임워크들은 모두 테스트 자동화를 충실히 지원하고 있다.\
테스트 자동화에 대한 시장의 요구가 분명한 것이다.\
규모있는 오픈소스 프로젝트들 역시 테스트 코드가 어느 정도 비중을 차지한다.\
테스트가 잘 갖춰줘 있으면 대체로 좋은 코드일 확률이 높은데 좋은 코드가 아니면 테스트를 갖추기가 어렵기 때문이다.

좋은 코드가 실제하는 것이라면 왜 우리는 좋은 코드를 작성하는 것이 어려울까?

그것은 우리의 생각보다 좋은 코드에 대한 더 많은 이해와 경험이 필요하기 때문이다.
<!-- 괜찮아 보이는 소스코드의 비율이 어느 정도인지 잘 생각해 보자.
나는 드물다고 생각한다. 그 정도로 소수의 프로그래머가 가능한 것이다.
리팩토링을 공부한다고 해서, 디자인 패턴을 외운다고 해서 가능한 수준이 아니다. -->
무엇을 알아야 할까?

<!-- 지금 이 글을 읽고 있는 당신은 어느 단계에 있는가?

그 좋다는 개발 방법을 열심히 공부하고 적용하는데 왜 안 될까?
그게 끝이 아니기 때문이고 끝까지 아우르지 못하면 소용이 없기 때문이다.
그래서 이 글은 내가 겪은 시행착오 과정을 정리한 것이기도 하다. -->
일반적으로 코드를 구현하는 것으로 출발한다.
OOP와 패턴을 이용해서 좋은 코드를 작성하는 것에서 시작해 보자.


## 구현이 어렵다. 이름 짓기

### 1. OOP와 패턴을 이해하기 어려운 이유

무엇이 어떻게 변할 것인지 파악되지 않아서다.

1. 기초 서적에서 제시하는 예시는 자동차, 사과와 같은 일반적인 사물이다. 그렇다 보니 형태가 있는 사물에 대해서만 객체로 해석하려는 경향이 있다. 그러나 시간, 약속, 건강상태 등도 모두 객체다.

1. 사실 함수 하나를 디자인 하는 것도 쉽지 않다. params로 user를 받을 것인가? user.id를 받을 것인가? 등등 선택의 기준은 무엇이 어떻게 변할 것인지 예측하기에 달렸다.\
그런 예측은 전체 구조에 영향을 줄 수 있다. 함수와 호출자 외에 전체적인 구조에 따라 달라진다.

> 같은 구역이면 user 다른 구역이면 userID

문제를 인식해야 필요성을 느끼고 해결책으로 객체지향적인 생각을 하게 되는데, 그렇지 못하기 때문에 OOP로 사고하는 것이 어렵다.
코드의 일부분만을 보고 그것이 전체에 미칠 영향을 파악할 수 있어야 한다. 이것은 많은 경험과 학습이 필요하다.

다음의 코드에서 어떤 문제가 있을 수 있을까?

```typescript
switch (lang) {
  case "kor":
    "안녕";
    break;
  case "eng":
    "hello";
    break;
  default:
    "unknown";
    break;
}
```

어떻게 하면 해결할 수 있을까?

```typescript
interface Country {
  hello(): string;
}

class KOR {
  public hello() {
    return "안녕";
  }
}

class ENG {
  public hello() {
    return "hello";
  }
}

const country = new KOR();
country.hello();
```

문제에 따른 해결책에 차이는 있겠지만 다른 패턴도 의존성/응집성에 대한 이야기다.

### 2. 테스트는 어렵다.

패턴에 익숙하기만 할 뿐이다. 코드 작성 중에 전략패턴과 같은 다양한 패턴을 익숙하게 구현할 수는 있지만 그것이 설계는 아니다.
설계 없이 이렇게 저렇게 바꿔가며 구현하는 중에 사용하는 도구 중에 하나일 뿐이다.
혹은 그것이 설계라고 한다면 적어도 요구사항을 분석하는 능력이 부족한 것이다.

레이어드 아키텍쳐에 대한 이해. 상위 레이어에 대한 이해.

사족->사실 패턴도 유사하다, 무엇이 적절한 패턴인지 판단하려면 더 상위의/다른 객체의/환경 분석이 필요하다.

요구사항을 먼저 구체화 할 수 있어야 한다.

이것이 어렵기 때문에 DB먼저 설계하는 상향식 개발을 하게된다.

그런데 요즘은 orm을 사용해서 DB를 직접 사용하는 것을 피한다.

> 아포스티유 프로젝트에서 유사한 형식의 두 종류 문서가 있었다. 기존 구현된 DB는 하나로 관리하고 있었고 두 종류로 나누는 것은 번잡하게 느껴졌다. 그러나 내용이 유사하다 하더라도 두 개의 개별적인 문서다. 우연히 내용이 비슷하다고 해서 이것을 하나의 문서로 취급하면 나중에 기능이 확장될 때 문제가 될 수 있다.
> 실제로도 그랬다. 다행히 db는 하나로 관리해도 service api는 두 종류로 구분해서 문제가 크게 번지지는 않았다.
> 상위 레이어 혹은 분석에서 시작하는 것이 아니라 분석과 구현 단계의 구분없이 개발이 진행되면 흔히 발생한다.
> 이런 통찰력이 없으면 분석이 제대로 되지 않고 설계와 구현까지 두루 영향을 미친다.

### 3. 그러나 요구사항 구체화는 어렵다.

눈에 보이지 않는 무형의 논리와 개념을 체계적으로 시각화 하는 것은 원래 어려움. 건축은 그림으로 그리고 규격화도 되어있다.
그래서 프로그래머들은 습관적으로 DB부터 정의한다. 당장 눈에 보이고 동작하기 때문이다.
그러나 이런 상향식 설계는 결국 도메인과 구현의 불일치에 도달하게 된다.

설계의 중요성이 여기서 드러난다. 추상적 개념을 분석하고 눈에 보이는 문서로 표현할 수 있어야 한다.
대표적으로 UML이 있겠으나 형식은 상관없다.
21세기 초, 우리나라에서는 이 UML이 유행했었고 그렇게 지나갔다.
왜 그랬을까?
분석을 구체적으로 표현하지 못한다. 분석을 기반으로 설계를 해야 하는데 Layerd arch. 같은 개념의 이해 이전에 제대로 된 분석 문서가 없는 것이다.
어떻게 하면 분석한 내용을 UML같은 도구를 사용해서 문서로 표현할 수 있을까?

분석 -> 설계 -> 구현 -> 테스트의 반복인데 시작이 어렵다.

1. 분석은 어떻게 하는가? 어떻게 구체화 할 수 있는가? 누가/무엇을 하는지부터 시작해라. Use Case, Activity
   1. 예외 : 익숙하지 않은 기술을 사용하는 경우 연구와 개발을 병행하게 된다. 이런 경우에는 설계 후 구현이 힘들다.
      꼭 기술이 아니라도 요구사항 자체가 확정적이지 않은 경우가 있다.

### 4. 설계는 어렵다


### 결론 - 프로그래머는 왜 변화에 대응하기 어려운가.

하향식 개발을 지향해야 제대로 할 수 있다. 그러나 많은 것을 이해하고 경험하지 못하면 구체화 하기 어렵기 때문에 상향식을 추구하게 된다.
할 수 있는 것은 상향식이고 해야 하는 것은 하향식이다. 그 간극 만큼이나 개발방법론 등이 비현실적으로 느껴지게 된다.
여기서 얘기하려는 것은 그 간격을 매울 수 있는 기회가 되길 바란다.
