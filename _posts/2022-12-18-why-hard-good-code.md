---
layout: post
title: "2. 좋은 코드의 어려움"
---

좋은 코드를 작성하고 싶지만 무엇이 좋은 코드이고 어떻게 하면 되는지 모르는 경우가 많다.\
널리 알려진 소스코드를 보면 어딘지 모르게 깔끔하고 읽기가 쉬운데 내가 작성한 코드는 아무리 노력해도 어설프다.\
그래서 '리팩토링'을 공부하고 '클린 코드' 같은 책도 읽어보지만 크게 도움이 되지 않는다.

좋은 코드를 향한 노력은 보통 아래의 순서로 진행이 된다.

1. 리팩토링을 학습, 코드가 조금 개선된다.
2. 디자인 패턴을 학습, 코드가 그럴듯해 보인다.
3. 유닛 테스트 작성, 프로젝트가 그럴듯해 보인다.

그리고 얼마 지나지 않아서 새로운 요구사항이 나타나면 아래의 순서로 좌절하게 된다.

1. 클래스를 유연하게 만들었다고 생각했다.\
그러나 클래스가 새 요구사항을 수용하지 못해서 크게 변경하게 된다.
2. 클래스가 변경되면서 세심하게 작성한 테스트가 동작하지 않는다.\
그러나 다시 작성하려니 많은 노력이 필요해서 그냥 삭제하게 된다.
3. 코드가 크게 변경되면서 리팩토링이 필요해졌다.\
그러나 프로젝트의 진행이 더뎌서 다음으로 미룬다.

안타깝게도 많은 프로그래머들이 이런 실패를 몇 번 경험하면 좋은 코드에 대한 노력을 포기하고 좋은 코드를 책에서나 나오는 이상론으로 치부하게 된다.\
그러나 현대적인 개발 프레임워크들은 모두 테스트 자동화를 충실히 지원하고 있고 규모있는 오픈소스 프로젝트들 역시 테스트 코드의 비중이 높은 편이다.\
테스트를 언급하는 이유는 테스트가 잘 갖춰져 있으면 대체로 좋은 코드일 확률이 높은데, 좋은 코드가 아니면 테스트를 갖추기가 어렵기 때문이다.

좋은 코드가 실제하고 또 충분히 실용적이라면 우리는 왜 좋은 코드를 작성하는 것이 어려울까?\
크게 두 가지가 부족하기 때문인데 하나는 객체지향에 대한 이해이고 다른 하나는 분석과 설계다.

### 객체지향의 어려움
#### 객체지향의 장점
객체지향에 대한 좋은 설명들은 이미 거장들의 책 속에 있어서 여기에서는 단순히 소개만 한다.\
다만, 몇 개의 단어를 '절차식'과 '객체지향'으로 통일했다.

객체지향을 사용해야 하는 이유와 장점은 아래와 같다.

> 경험에 비춰보면 객체지향을 우선 적용하는 것을 선호한다.\
> 이러한 접근 방법이 소프트웨어 시스템의 고유 복잡도를 정리하는 데 더 도옴을 주기 때문이다.\
> 이는 앞서 컴퓨터, 식물, 은하계, 대규모 사회 조직과 같이 다양하고 복잡한 시스템에서 복잡한 구성을 묘사하는 데 객체지향이 도움이 된 것과 마찬가지다.\
> 객체지향은 절차식과 비교해 보면 여러 중요한 장점이 있다.\
> 객체지향은 공통으로 사용하는 **메커니즘을 재사용**함으로써 전체 시스템을 작게 유지하기 때문에 시스템을 더 경제적으로 표현한다.\
> 또한 객체지향은 변화에 더 유연하게 대처할 수 있으며, 안정된 중간 형태를 기반으로 하기 때문에 시스템을 키워 나가기에 더 적합하다.\
> 실제로 객체지향으로 복잡한 소프트웨어 시스템을 구측하면 위험을 줄일 수 있다.\
> 이는 이미 증명된 작은 시스템으로부터 점진적으로 진화하면서 설계했기 때문이다.\
> 더 나아가 객체지향은 소프트웨어 고유의 복잡도에 직접 대응한다.\
> 광범위한 상태의 공간에서 관심을 분리해 사려 깊은 판단을 돕기 때문이다.
>
> Object Oriented Analysis and Design with Applications, 49p

여기에서 '메커니즘을 재사용'한다는 것은 절차식에서 함수를 공유하는 것과는 다르다.\
예를 들어, 입력을 받기 위해서 `interface InputStream`을 정의하면 상황에 따라서 `class BufferInputStream`나 `class FileInputStream`인 것과 같다.\
이 때 InputStream을 제공하는 코드를 새로 정의할 뿐, InputStream을 사용하는 코드는 아무런 변경이 없다.\
이것이 stream을 입력받는 매커니즘을 재사용하는 것이다.\
지금 이것이 무슨 말인지 이해하기 어렵다면 나중에 더 자세히 설명할 기회가 있을 것이다.

<!-- 만약 절차식이고 `func InputStream(buffer)`이라는 함수가 있다면 이것을 변경해서 `func InputStream(buffer, file)`이라는 함수로 만들어야 했을 것이다.

Buffer와 File외에 Pipe 같은 다른 스트림이 추가되어야 한다면 어떨까? 절차식 함수라면 전달인자(argument)가 점점 늘어나고 복잡해질 것이다. -->

<그림 1-3>과 <그림 1-4>는 절차식과 객체지향의 구조적 차이점을 보여준다.

<img src="/assets/refs/booch-46-seq.png">
<img src="/assets/refs/booch-47-oop.png">

함수로 이루어진 절차식 구조의 관계는 단순해서 흐름을 파악하기 쉽다.\
반면에 객체지향은 몇 개의 클래스가 서로 연결되어있어서 작업의 흐름을 파악하는 것이 어렵다.\
그러나 객체지향은 몇 개의 큰 덩어리들이 응집성 있게 구성되어 있어서 다른 기능을 구현할 때 재사용하기 쉽다.\
또 그런 특징들 때문에 변화의 영향이 다른 클래스에 미치지 않도록 해준다.\
반면에 절차식 구조는 작은 함수 정도만 재활용 가능한데 만약에 'Update file'과 같은 큰 함수를 무리해서 재사용 하려고 하면 함수를 호출할 때 인자(argument)가 늘어나고 점점 복잡해지게 될 것이다.\
reformat함수를 호출하는데 ext4나 ntfs등을 선택하고 싶다면 어떻게 해야 할까? update와 get formatted update가 모두 ext4를 인자로 받아야 한다.\
`updateFile(filepath)`에서 `updateFile(filepath, overwritable)`으로 함수가 확장되어야 할 것이다.\
그러면 updateFile에서는 if(overwritable)이 들어갈 것이고 updateFile을 사용하는 모든 부분에서 overwritable을 설정해야 할 것이다.\
if같은 조건문이 늘어나면 코드의 복잡도가 크게 올라가게 되는데 객체지향은 이런 조건문의 사용을 줄일 수 있다.

지금까지 언급한 객체지향의 장점 때문에 현대적인 개발 방법의 근간에는 객체지향이 있다.\
그러니까 객체지향을 이해하지 못하면 규모있는 소프트웨어 개발이 어렵고 개발 방법 자체를 이해하기가 쉽지 않다.

예를 들면,

1. 테스트 자동화의 상당 부분은 의존 주입(Dependency Injection)을 사용한다.
1. 의존 주입은 디자인패턴의 '전략패턴'에 해당한다.
1. 디자인패턴은 객체지향 설계에 기반한다.

그 외에도,

- MSA(Micro Service Architecture)는 디자인 패턴 중 '옵저버'에 해당한다.
- 애자일 방법론은 짧은 개발주기가 특징인데 이것은 객체지향 설계와 잘 맞는다.


#### 객체지향 이해의 어려움
객체지향이 이렇게 많은 장점이 있음에도 불구하고 실제로 객체지향을 제대로 이해하는 프로그래머는 많지 않다.\
대부분은 처음 프로그래밍을 학습할 때 1부터 10까지 출력하는 간단한 함수로 시작해서 자연스럽게 절차식 프로그래밍에 익숙해진다.\
그러나 그래디 부치는 객체지향과 절차식은 근본부터 다르다고 했는데 이것이 절차식에 익숙한 프로그래머들이 객체지향을 이해하기 어려운 이유일 것이다.

> 객체지향은 기존 절차식 설계와는 근본부터 다르다.\
> 분해할 때 사고 방식도 전혀 다르다.\
> 그 결과로 나온 소프트웨어 아키텍처는 구조적 설계 문화 영역과는 멀리 떨어져 있다.
>
> Object Oriented Analysis and Design with Applications, 57p

어떻게 하면 객체지향을 이해할 수 있을까? 마틴 파울러의 이야기를 읽어보자.

> 대부분의 사람들(특히 객체를 처음 접하는 사람들)은 중앙 집중형 제어에 익숙하다.\
> 여러 가지 면에서 중앙 집중형 제어는 모든 처리가 한 곳에서 일어나므로 단순하다.\
> 반면 분산 제어는 프로그램을 이해하려면 객체들을 따라다녀야 한다.\
> 하지만 필자 같은 객체 광신도들은 분산 제어를 훨씬 더 선호한다.\
> **좋은 설계의 목표 중 하나는 변경의 영향을 최소화하는 것이다.**\
> 데이터와 그 데이터에 접근하는 행동은 함께 변경되는 경우가 많다.\
> 따라서 데이터와 그 데이터를 사용하는 행동을 한 곳에 놓는 것이 객체 지향 설계의 첫 번째 규칙이다.\
> 게다가 분산 제어를 사용하면 조건문 대신 다형성을 사용할 수 있는 기회가 더 많이 생긴다.\
> 만약 제품의 가격을 결정하는 알고리즘이 제품의 형태마다 다르다면, 분산 제어 방식은 Product의 하위 클래스를 이용하여 이런 다른 알고리즘을 해결할 수 있도록 헤준다.\
> 보통 객체 지향 형식에서는 작은 메소드를 많이 가진 작은 객체를 많이 사용하며, 이것은 재정의(override)와 변형(variation)에 필요한 많은 접점(plug point)을 제공해 준다.\
> 이와 같은 형태는 긴 프로시저에 익숙한 사람들에게는 아주 혼란스러운 것이다.\
> 하지만 이런 변화가 객체 지향으로의 패러다임 전환의 핵심이다.
>
> UML Distilled, 68p

마틴 파울러는 이어서 다음과 같이 말했는데 이것이 이 블로그의 주된 목적이다.

> 이것은 가르치기는 매우 어려운 것이다.\
> 제대로 이해하려면 분산 제어를 아주 많이 사용하는 객체 지향 환경에서 얼마간 일하는 수밖에 없는 것 같다.\
> 분산 제어를 이해하는 순간, 갑자기 "아 그렇구나." 라고 느끼게 된다고 많은 사람들이 말한다.\
> 그 순간부터 뇌의 구조가 바뀌어서 분산형 제어가 훨씬 쉽다고 생각하기 시작한다.


> 좋은 설계의 목표 중 하나는 변경의 영향을 최소화하는 것이다.

라고 마틴파울러가 언급했다. 그런데도 왜 꼬이기만 할까?
그렇다면 객체지향과 디자인패턴에 능숙해졌는데 왜 계속 코드가 꼬이기만 할까?
또는 대규모 리팩토링이 왜 계속되고 프로젝트 진행이 더딜까?
소프트웨어를 설계하기 위한 기본은 갖췄는데 왜 안 될까? 왜 계속 변경될까?
분석이 제대로 이루어지지 않아서 그렇다.

분석과 설계 스타일은 사람마다 다르다고 한다. 어느 정도는 맞는 말이다.\
그러나 올바른 결정을 할 수 없을 때 스타일로 치부하는 경향이 있다.\
분석과 설계는 주관적이고 추상적이기 때문에 소프트웨어의 근본 개념까지 쫓아가게 된다.\
소프트웨어 공학 이론은 실무에서 쓸모없는 것으로 치부하는 프로그래머가 많다.\
그러나 실력이 쌓이고 쌓이면 언젠가는 소프트웨어의 근본과 철학에 대한 고민을 하게 될 것이다.

### 분석과 설계의 어려움
