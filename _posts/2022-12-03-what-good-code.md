---
layout: post
title: "좋은 코드란 무엇인가?"
---

## 프로그래머의 실력

사람은 누구나 자기가 노력하는 분야에서 실력으로 인정받기를 원한다.\
프로그래머도 마찬가지인데 문제는 실력의 기준이 제각각이라는 것이다.\
누군가는 알고리즘 같은 기본기를 중시하고 또 누군가는 빠르게 기능을 구현하는 것이 실력의 기준이 된다.\
거기에 디버깅도 잘 하고 최신 기술도 많이 알면 보통은 실력있는 프로그래머로 인정 받는 것 같다.

그러나 그게 전부일까?\
SDK의 문서를 읽고 기능을 구현하는 것은 당연하고 평범하다.\
알고리즘도 몇 개 정도를 이해하면 나머지는 개인의 재능에 따른 응용일 뿐이다.\
과연 주니어 프로그래머와 시니어 프로그래머의 차이가 이런 기술의 숙련된 정도일까?

내 생각에 프로그래머의 실력은 `얼마나 좋은 코드를 작성할 수 있는가`에 달렸다.\
물론 좋은 코드라는 표현은 추상적이라서 이에 대한 정의도 각자 조금씩 다를 것이다.\
그러므로 이 글은 좋은 코드가 무엇이고 왜 그렇게 됐는지에 대한 나의 생각이다.

프로그래머의 실력에 한정해서 이야기하는 것에 주의하기 바란다.\
좋은 프로그래머라면 실력 뿐만이 아니라 커뮤니케이션 능력을 포함하는 현명함도 갖추어야 한다.\
나 자신이 좋은 프로그래머라는 확신이 없고 이에 대한 정답도 존재할 것 같지 않다.

## 좋은 코드란 무엇인가?

좋다/나쁘다라는 주관적 평가는 상황에 따라 다르기 때문에 정의하기가 조심스럽다.\
그러나 주변 프로그래머들에게 물어봤을 때 대체적인 공통된 답변은 '읽기 쉽고 변경하기 쉬운 코드'다.\
여기서 코드를 읽는 목적은 코드를 변경하기 위해서이기 때문에 이것은 결국 `변경하기 쉬운 코드`로 축약할 수 있다.

프로그래머들은 왜 변경하기 쉬운 코드를 좋은 코드라고 생각할까?\
코드의 집합체인 소프트웨어를 자주 변경해야 하기 때문인데 주로 사용자 요구사항과 분석 과정에서의 오류가 원인이다.\
그 외에 종종 운영 환경이 변하기도 하는데 몇 가지 예를 들면 아래와 같다.

1. OS가 업그레이드 되면서 API가 변경된다(특히 Apple OS들이 적극적이다).
1. 외부 인증 서비스가 중단되거나 비용이 높아져서 다른 서비스로 교체해야 한다.
1. 사용량이 증가하면서 성능 하락의 문제가 발생한다.
1. 사용하는 라이브러리에서 보안 취약점이 발견되거나 라이센스 정책이 변경된다.

이와 같이 어떤 식으로든 변경은 발생하고 기능 개선의 요구도 끝없이 나오는 것이 보통이다.

## 요구사항이 변경되는 이유

운영환경이야 어쩔 수 없다고 해도 요구사항 변경을 최소화 할 수는 없을까?\
무엇을 만들 것인지 신중하게 분석하고 설계하면 시행착오를 줄일 수 있을 것도 같다.
<!-- 그렇게 하면 분석 단계에서의 오류도 줄일 수 있을 것 같다. -->

그러나 대부분의 프로젝트들이 이런 문제를 갖고있을 만큼 생각처럼 쉽지는 않다.
이 정도 되면 그냥 소프트웨어 개발이 원래 그러려니해야 하고 이런 어려움을 최소화 하는 개발 전략을 세워야 한다.

<!-- 생각해 보면 건축물은 이렇게 자주 변경하지 않는다. 설계를 마치고 시공 단계에 들어가면 변경은 거의 이루어지지 않는다. -->
왜 소프트웨어는 뼈대에 해당하는 부분까지도 자주 변경하게 될까?
그래디 부치의 저서에서 이에 대한 그의 통찰을 읽을 수 있다.
아래는 거기에 나의 의견을 추가하는 것이다.

### 소프트웨어의 유연성

소프트웨어라는 이름에서 알 수 있듯이 유연성은 소프트웨어의 본질적 특성이다.
많은 책에서 유연성으로 정의해서 나도 그렇게 언급하지만 나는 무형이라는 말이 더 맞는 것 같다.
소프트웨어는 논리와 개념의 집합으로 이루어진 무형의 산물이다.
형태가 없기 때문에 변경하기 쉽고 그 만큼 구체화 하기도 어렵다.

건축은 지어질 건물을 3D모델링도 하고 미니어쳐로 만들어 보기도 한다.
그러나 소프트웨어는 사용자에게 보여지는 화면을 모두 구체화 할 수 없다.
구현해야 하는 개념을 사용자가 이해할 수 있는 눈에 보이는 형태로 표현하는 것도 어렵다.

<!-- 사실 건축물도 건물 안쪽까지 모두 그리지는 않을 것이다. 인테리어 화면까지 요구하지는 않는다. -->

개발이 진행될수록 사용자와 개발자 사이의 생각의 차이가 드러난다. 사용자의 생각을 구체화된 형태로 표현할 수 있다면 이런 시행착오는 줄어들 수 있다.

사용자의 생각을 제대로 파악하는 것도 어려운데 사용자의 생각은 계속 바뀌기까지 한다.
건물을 지을 때는 설계가 거의 변경되지 않는데 이미 지어진 구조물을 변경하기 어렵기 때문이다.
그러나 소프트웨어는 언제든지 변경할 수 있다는 환상이 있다.
건물처럼 눈에 보이는 구체화된 것도 없기 때문에 사용자의 생각은 계속 바뀐다.

그래서 변화를 수용할 수 있는 코드를 작성하는 것이 좋다.

<!-- 추가로 변경과 공유(복제)가 쉽기 때문에 규격화가 안 된다.
복제가 가능하다. 같은 물건을 만들기 위해서 공장을 다시 지을 필요가 없다.
한 번 잘 만들어 놓으면 많은 사람들이 여러번 사용할 수 있다.
변경의 효용이 어려움을 능가하는 것이다. 즉, 비용 효율적이다. -->

### 하드웨어의 발전

하드웨어는 소프트웨어를 담는 그릇이라고 할 수 있는데 하드웨어의 발전이 빠르면 그 만큼 소프트웨어의 발전도 빠르기 마련이다.
예를 들어,

- CPU와 메모리가 발전하면서 텍스트 기반의 OS에서 GUI 기반의 OS가 생겼다.
- CPU가 충분히 작아지면서 스마트폰이 생겼고 그에 따르는 수 많은 앱이 생겼다.
- CPU가 단일코어로 성능향상이 어려워지면서 이제는 8개의 코어는 기본이 됐고 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화했다.
- 통신 인프라가 발전하면서 클라우드 컴퓨팅이라는 개념이 생겼다.
- CPU와 메모리가 발전하면서 가상화를 쉽게 수행하게 됐다.

VR이 대중화 된다면 그에 맞는 새로운 인터페이스도 기대할 수 있고 SSD의 속도가 충분히 빨라져서 메인 메모리의 개념이 사라질지도 모른다.

이렇게 발전하는 하드웨어에 맞춰서 그에 맞는 새로운 플랫폼과 개념들도 생겨나고 있다.
그래서 현재 잘 사용하고 있던 소프트웨어도 금방 구식이 되기 때문에 다시 만들던가 업그레이드를 하게 된다.
어느 쪽이든 가능하면 기존 코드를 활용하는 것이 시행착오를 줄일 수 있는 방법이다.

## 변화에 대응하는 개발 방법들

변경하기 쉬운 코드로 글을 시작했지만 여기서 말하는 코드는 함수 단위의 좁은 의미의 코드가 아니다.
플랫폼 인터페이스 변화에 대응하는 것을 포함한다.

위와 같은 이유로 개발방법은 변화를 중심에 두고있다.
어떤 것들이 있는지 살펴보자

### 리팩토링과 변화

왜 읽기 쉬운 코드를 좋은 코드라고 할까?
마틴은 쓰기 보다는 읽기가 많다 등등의 이유를 들었다.
쓰기 위해서 읽는 것이고, 쓴다는 것은 변경한다는 뜻이다.
auto나 const와 같이 타입을 생략하는 이유도 간편한 표기 외에 타입 변화에 대응한다는 의미다.

왜 상태가 적은 클래스를 지향해야 하는가?
상태=변수를 통해서 메소드들이 연결되기 때문이다. 다시 말해서 의존성이 높아진다.

### 디자인 패턴과 변화

추상화를 사용해서 의존성 관리.

### OOP와 변화

OOP를 학습할 때 할 일을 객체에 일임한다는 것을 알 것이다. 의존성과 응집성을 관리하는 것이다.
이 원칙은 디자인 패턴에서 자세히 나온다.
SOLID에서 제시하는 것은 변화에 대응할 수 있는 기본 원칙이다.

> SOLID 5원칙이 각각 변화에 어떤 영향을 주는지 서술한다.

## 아키텍쳐

몇 가지 대표적인 아키텍쳐를 살펴보자.
backend라면 Layerd Arch와 MSA,
frontend라면 MVC/MVVM을 대표적인 아키텍쳐라고 할 만하다.

### MSA 소개

MSA는 다른 서비스의 의존성을 최소화 한다.
각각의 서비스들은 다른 서비스에 독립적으로 동작하도록 개발된다.
이것은 서비스를 사용하지 않는다는 것이 아니다. 서비스의 변화에 독립적이라는 뜻이다.
시스템 레벨에서도 마찬가지다

다양한 개발언어와 팀의 상황에 맞춰서 서비스를 개발한다.
모놀리식은 통일된 도구를 사용하게 된다.
다양한 상황에 대응하는 시스템 구조 = 변화를 수용

### MVC(MVVM) 소개

MVC에서 MVP를 거쳐서 지금은 MVVM을 많이 사용하는 것 같다. .NET의 WPF는 물론이고 iOS(SwiftUI)와 android도 MVVM 구조를 지원한다.
MVC든 MVVM이든 요점은 Model과 View를 분리한다는 것이다.

### 아키텍쳐와 변화

이들 아키텍쳐의 지향점은 무엇인가? 이 아키텍쳐의 공통된 장점은 무엇일까?
한 부분에서의 변화가 다른 부분으로 전파되지 않도록 한다.
아키텍쳐는 응집성/의존성을 전반에 걸쳐 준수하도록 한다.

아키텍쳐는 최대한 단순해야 한다. 규칙이 복잡할수록 고려하지 못한 예외 사항이 발생하기 쉽고 대처하기 어렵다. 또한 그 만큼 외부 변화에 취약하다.

DDD는 언뜻 변화와 무관해 보일 지도 모르겠다. 요구사항의 변경은 최하위 레이어인 인프라스트럭쳐까지 영향을 준다.
도메인의 의미를 잘못 파악해서 구현하면 결국 많은 부분을 고치게 된다. 또 도메인이 변경되면 많은 부분을 고쳐야 하기 때문에 결국 변화할 수 없다. 도메인을 최상위에 놓는다는 것은 도메인이 변경될 때 영향을 최소화 하겠다는 뜻이다.
DDD는 도메인의 변화가 구현된 시스템에 끼치는 영향을 최소화 한다.

요즘의 최신 백엔드 프레임워크는 DDD에 기반한 Layerd arch와 MSA를 잘 지원하는 방향으로 발전하고 있다.

### 테스트 자동화와 변화

비행기는 시간이 흐르면서 내부의 부품이 계속 마모되는 변화가 발생한다. 소프트웨어는 외부 환경이 변화한다. 변화가 어느 쪽에서 일어나든 그것은 시스템 전반에 영향을 준다. 그 시스템이 복잡하다면 테스트 없이 생존할 수 없다.
테스트 자동화는 일반적이다. 우리가 사용하는 대부분의 개발 프레임워크의 가이드를 보면 테스트가 있다.

## 애자일 방법론

### 애자일 소개

집을 지을 때 처음 설계를 마치고 시공을 하는 중에도 끊임없이 수정하고 싶은 욕구가 생긴다. 여기에 전등을 달고 저기에 스위치를 옮기고 창은 좀 줄이고 등등.
이것은 인간이 창의적이기 때문이다. 그리고 이런 과정은 소프트웨어를 개발할 때도 마찬가지다.
요구사항은 계속 변한다. 그것이 고객의 요구이든 분석 단계에서 오류가 있든 간에 말이다.
애자일은 이런 요구사항의 변화에 대응하기 위한 개발 전략이다.

### 애자일과 변화

## cross-platform, 이 파트는 결론에 간단하게

### Java, NET 소개

.NET이 뒤늦게 나왔고 비교적 세련된 기술이다.
그럼에도 시장 점유율은 낮은 편이다. 개선된 장점이 흐름을 바꿀 만큼 크지 않은 것이다.

### Flutter, React Native 소개

### Docker 소개

> Linux® 컨테이너는 시스템의 나머지 부분과 분리된 1개 이상의 프로세스 세트입니다. 이러한 프로세스를 실행하는 데 필요한 모든 파일은 고유한 이미지에서 제공되므로, Linux 컨테이너는 개발 단계에서 테스트, 프로덕션에 이르기까지 이식성과 일관성을 유지할 수 있습니다. 따라서 전통적인 테스트 환경을 복제하는 데 의존하는 개발 파이프라인보다 사용 시점을 훨씬 더 앞당길 수 있습니다. 대중성과 사용의 편의성 때문에 컨테이너 역시 IT 보안의 중요한 부분입니다.

실행에 필요한 환경을 모두 하나의 패키지로 관리한다는 것은 응집성/의존성의 특징이다.

### 크로스 플랫폼과 변화

ios/android를 지원하는 Flutter, Java, .NET은 OS의 변화에 대응하기 쉬운 환경을 제공한다. 물론 one source multi use가 플랫폼의 의도였겠으나, 다양한 환경에 적응하는 플랫폼이라는 것은 변화에 잘 대응하는 플랫폼이라는 말과 같다.

## ORM(이것도 억지스럽네3)

### ORM 소개

ORM과 OOP의 관계

### ORM과 변화

typeorm, mybatis와 같은 ORM들은 다양한 SQL을 통일된 방법으로 사용할 수 있게 한다.
SQL 마다 문법이 조금씩 다르다. 본래의 취지는 말 그대로 Object Relation Modeling이겠으나 부수적인 효과로 통일된 인터페이스를 통한 SQL에 독립적인 코드를 지원한다.

## 결론

### 좋은 코드의 특징

지금까지 살펴본 개발방법과 도구들의 공통점은 변화에 대응한다는 것이다.
변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다.
그것은 코드도 마찬가지인데 좋은 코드는 변화에 적응하기 쉬운 특징을 가진다.
변화에 대응하기 좋은 코드의 특징은 의존성이 낮고 응집성이 높은 것이다.

그림(의존성/응집성)

그래서 패턴이나 아키텍쳐의 핵심은 규모가 다를 뿐이지 의존성/응집성에 대한 이야기다

의존성/응집성
다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 한다.

몇몇 책에서도 의존성과 응집성을 직접적으로 이야기 한다.
그렇지 않더라도 방법과 방법론에 대한 '모든' 서적은 변화에 대한 이야기다.

많은 이들이 개발 언어와 도구에 집착하는 것으로 보인다.
그러나 문제의 본질을 통찰하고 예측할 수 있다면 대응은 비교적 쉬운 편이고 도구도 올바르게 사용할 수 있다.

### 급변하는 개발환경에 대처하는 자세

React, NodeJS와 같은 응용기술이 변화가 빨라서 한 프로그래머가 여러 영역에 걸쳐서 전문성을 유지하기가 쉽지 않다.
패턴과 아키텍처와 같은 개발 이론의 지식은 쉽게 얻을 수 없으나 얻으면 모든 분야에 유용하다. 설계 없는 개발이 가능하겠는가.

어떤 이는 내가 아무리 잘 해도 다른 프로그래머들이 이해하기 어려운 기술은 실무에서는 쓸 수 없다고 말한다.
시니어나 팀장이 되면 전체적인 틀을 잡고 주니어들에게 가이드를 하며 작업을 진행한다.
이 때 소프트웨어 공학에 능숙하다면 더 나은 가이드를 할 수 있다.
나의 경우에는 프로젝트를 처음 시작할 때 내가 먼저 테스트를 포함한 기본적인 기능을 구현하면 팀원들이 그것을 응용해서 작업을 한다. 응용할 만한 것이 없는 경우에는 언제든지 내가 작업한다.
컴퓨터가 개발된 초기에는 하드웨어 성능이 부족했다. 그러나 지금은 성능에 여유가 있다. 그래서 소프트웨어는 성능 효율이 비교적 부족해도 변경 효율적인 쪽으로 발전하고 있다. 도커나 크로스플랫폼이 그렇다. 이에 맞춰서 현대의 좋은 코드는 변화에 잘 적응하는 코드다. 컴퓨터 초기라면 효율과 성능이 좋은 코드였겠지만 말이다.

### 이유

왜?가 제일 중요하다 우리가 접하는 많은 개발 방법과 도구들이 왜 그렇게 되었는지 이해하면 더 잘 이해할 수 있다.
OOP에 대한 경험이 부족한 프로그래머라면 리팩토링 디자인패턴을 그냥 읽기 보다는 변화라는 프레임에서 읽는다면 이해하는 데 도움이 될 것이다.

### 기타
실제로 경력이 10년 정도를 넘게되면 반복되는 작업에 더 성장하지 못하는 프로그래머들을 많이 봐왔다.
그런 프로그래머들에게 소프트웨어 개발은 별 것 없는 정이 경력이 오래될수록 생각이 고착화 되는 것 같다.
<!-- 많이 아는 것이 무의미한 것은 아니다.
그러나 지금의 기술이 쉽게 구식이 되는 이 분야에서는 다른 것이  -->

<!-- 흔히 이야기하는 좋은 소프트웨어는 사용자의 평가로써 `사용하기에 편하고 최소한의 시스템 자원으로 효율적이고 안정적으로 운영되는 것`이다.
반면에 좋은 코드는 프로그래머의 평가다. -->
