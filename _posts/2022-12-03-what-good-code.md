---
layout: post
title:  "좋은 코드란 무엇인가?"
date:   2022-12-03 16:12:03 +0000
categories: jekyll update
---
# 좋은 코드란 무엇인가?

좋은 코드란 무엇일까?

흔히 이야기하는 좋은 소프트웨어는 사용자의 평가로써 `사용하기에 편하고 최소한의 시스템 자원으로 효율적이고 안정적으로 운영되는 것`이다. 반면에 좋은 코드는 프로그래머의 평가다.

좋다/나쁘다라는 주관적 평가는 상황에 따라 다르기 때문에 정의하기가 조심스럽다.
그러나 주변 프로그래머들에게 물어봤을 때 대체적인 공통된 답변은 `읽기 쉽고 변경하기 쉬운 코드`다.
여기서 코드를 읽는 목적은 코드를 변경하기 위해서이기 때문에 이것은 결국 `변경하기 쉬운 코드`로 축약할 수 있다.

왜 변경하기 쉬운 코드가 좋은 코드가 되는 걸까?
소프트웨어가 쉽게 변화하는 만큼 코드가 그에 대응해야 하기 때문이다.

## 소프트웨어가 변화하는 이유

### 하드웨어의 발전
하드웨어의 발전 만큼이나 소프트웨어 산업도 빠르게 발전하고 있다.
이 두 분야의 발전은 불가분의 관계다.
예를 들어 하드웨어가 10배 정도 빨라지면 가능해지는 여러 소프트웨어적인 기능들이 생긴다.
CPU가 충분히 작아지면서 스마트폰이 생겼다. 그로 인해 탄생하는 많은 소프트웨어들을 생각해 보자.
CPU가 단일코어로 성능향상이 어려워지면서 이제는 8개의 코어는 기본이 됐다.
그에 맞춰서 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화했다.
통신 인프라가 발전하면서 클라우드 컴퓨팅이라는 개념이 생겼다.
CPU와 메모리가 발전하면서 가상화를 쉽게 수행하게 됐다.
VR이 대중화 된다면 그에 맞는 새로운 인터페이스도 기대할 수 있다.
가까운 미래에는 SSD의 속도가 충분히 빨라져서 메인 메모리의 개념이 사라질지도 모른다.

이렇게 발전하는 하드웨어에 맞춰서 그에 맞는 새로운 플랫폼과 개념들이 생겨나고 있다. 그래서 현재 잘 사용하고 있던 소프트웨어도 금방 구식이 되기 때문에 다시 만들던가 업그레이드를 하게 된다.

### 표준화의 어려움
자주 사용하는 기능이 표준화 되어있으면 개발은 보다 수월해질 것이다. 그러나 많은 프로젝트에서 세부적인 기능까지 직접 구현하는 경우가 많다.
그래디 부치는 그의 저서에서 소프트웨어의 유연성이 표준화를 어렵게 만드는 요인으로 언급했다.

> 주텍 건설업자는 대체로 목재를 확보할 목적으로 목재 농장을 운영하지는 않는다. 건 측 회사가 새 건물에 쓸 맞춤형 철제 대둘보를 단조하려고 현장에 제강 공장을 세우 는 일도 국히 드물다. 하지만 소프트웨어 산업에서 이런 관행은 보통이다. 소프트웨어는 극한의 유연성을 제공하므로, 개발자로서는 어떤 종류의 추상화도 표현할 수 있다. 이런 유연성은 믿을 수 없이 매력적인 속성으로 밝혀졌지만, 개발자가 상위 수 준 추상 개넘을 올려놓을 뼈대에 해당되는 구성 요소까지도 수작업으로 공둘여 만들 게 된 요인이기도 하다. 건측 산업에서는 일관성 있는 건물 기준과 표준을 써서 원자 재 품질을 관리하는 체제를 갖춘 반면, 소프트웨어 산업에는 이런 표준이 거의 없다. 결과적으로 소프트웨어 개발은 노동 집약 산업 수준에 머물러 있다.

그러나 내 생각에 표준화가 안 되는 것은 소프트웨어의 발전이 빠르게 변하기 때문이다. 새로운 개념과 인터페이스가 성숙해지기 전에 더 개선되거나 새로운 개념이 계속 나오기 때문에 표준화 될 틈이 없다. 여기서 말하는 표준화의 대상은 프로토콜 뿐만 아니라 라이브러리나 프레임워크다.
예를 들어 REST API가 웹 인터페이스의 표준처럼 인식된 지 몇 년이나 지났다고 대안으로 RPC가 언급되고 있다. 라이브러리나 프레임워크도 그런 기능을 지원하기 위해서 변화하고 프로그래머도 그것을 쫓아가게 된다.

### 잦은 변경
하드웨어의 발전을 소프트웨어 변화의 첫 번쨰 원인으로 언급했지만, 소프트웨어의 이름 그대로 유연함이라는 본질적 특성이 보다 근본적인 이유다.
많은 책에서 유연함으로 얘기해서 나도 유연함이라고는 했지만 무형이라는 특성이 더 맞을 것 같다.
무형이기 때문에 구체화 하기 어렵다. 건축물은 지어질 집을 3D모델링도 하고 미니어쳐로 만들어 보기도 한다.
그러나 소프트웨어는 사용자에게 보여지는 화면을 모두 구체화 할 수 없다. 사실 건축물도 건물 안쪽까지 모두 그리지는 않을 것이다.
개발이 진행될수록 사용자가 개발자 사이의 생각의 차이가 드러난다. 형태를 구체화할 수 있다면 이런 시행착오는 줄어들 수 있다.

건물을 지을 때는 설계가 거의 변경되지 않는데 이미 지어진 구조물을 변경하기 어렵기 때문이다. 그러나 소프트웨어는 언제든지 변경할 수 있다는 환상이 있다. 건물처럼 눈에 보이는 구체화된 것도 없기 때문에 사용자의 생각은 계속 바뀐다.

추가로 변경과 공유(복제)가 쉽기 때문에 규격화가 안 된다.
복제가 가능하다. 같은 물건을 만들기 위해서 공장을 다시 지을 필요가 없다.
한 번 잘 만들어 놓으면 많은 사람들이 여러번 사용할 수 있다.
변경의 효용이 어려움을 능가하는 것이다. 즉, 비용 효율적이다.


## 변화에 대응하는 개발 방법들
위와 같은 이유로 개발방법은 변화를 중심에 두고있다.
어떤 것들이 있는지 살펴보자

### 리팩토링과 변화

왜 읽기 쉬운 코드를 좋은 코드라고 할까?
마틴은 쓰기 보다는 읽기가 많다 등등의 이유를 들었다.
쓰기 위해서 읽는 것이고, 쓴다는 것은 변경한다는 뜻이다.
auto나 const와 같이 타입을 생략하는 이유도 간편한 표기 외에 타입 변화에 대응한다는 의미다.

왜 상태가 적은 클래스를 지향해야 하는가?
상태=변수를 통해서 메소드들이 연결되기 때문이다. 다시 말해서 의존성이 높아진다.

### 디자인 패턴과 변화

추상화를 사용해서 의존성 관리.

### OOP와 변화

OOP를 학습할 때 할 일을 객체에 일임한다는 것을 알 것이다. 의존성과 응집성을 관리하는 것이다.
이 원칙은 디자인 패턴에서 자세히 나온다.
SOLID에서 제시하는 것은 변화에 대응할 수 있는 기본 원칙이다.

> SOLID 5원칙이 각각 변화에 어떤 영향을 주는지 서술한다.

## 아키텍쳐

몇 가지 대표적인 아키텍쳐를 살펴보자.
backend라면 Layerd Arch와 MSA,
frontend라면 MVC/MVVM을 대표적인 아키텍쳐라고 할 만하다.

### MSA 소개

MSA는 다른 서비스의 의존성을 최소화 한다.
각각의 서비스들은 다른 서비스에 독립적으로 동작하도록 개발된다.
이것은 서비스를 사용하지 않는다는 것이 아니다. 서비스의 변화에 독립적이라는 뜻이다.
시스템 레벨에서도 마찬가지다

다양한 개발언어와 팀의 상황에 맞춰서 서비스를 개발한다.
모놀리식은 통일된 도구를 사용하게 된다.
다양한 상황에 대응하는 시스템 구조 = 변화를 수용

### MVC(MVVM) 소개

MVC에서 MVP를 거쳐서 지금은 MVVM을 많이 사용하는 것 같다. .NET의 WPF는 물론이고 iOS(SwiftUI)와 android도 MVVM 구조를 지원한다.
MVC든 MVVM이든 요점은 Model과 View를 분리한다는 것이다.

### 아키텍쳐와 변화

이들 아키텍쳐의 지향점은 무엇인가? 이 아키텍쳐의 공통된 장점은 무엇일까?
한 부분에서의 변화가 다른 부분으로 전파되지 않도록 한다.
아키텍쳐는 응집성/의존성을 전반에 걸쳐 준수하도록 한다.

아키텍쳐는 최대한 단순해야 한다. 규칙이 복잡할수록 고려하지 못한 예외 사항이 발생하기 쉽고 대처하기 어렵다. 또한 그 만큼 외부 변화에 취약하다.

DDD는 언뜻 변화와 무관해 보일 지도 모르겠다. 요구사항의 변경은 최하위 레이어인 인프라스트럭쳐까지 영향을 준다.
도메인의 의미를 잘못 파악해서 구현하면 결국 많은 부분을 고치게 된다. 또 도메인이 변경되면 많은 부분을 고쳐야 하기 때문에 결국 변화할 수 없다. 도메인을 최상위에 놓는다는 것은 도메인이 변경될 때 영향을 최소화 하겠다는 뜻이다.
DDD는 도메인의 변화가 구현된 시스템에 끼치는 영향을 최소화 한다.

요즘의 최신 백엔드 프레임워크는 DDD에 기반한 Layerd arch와 MSA를 잘 지원하는 방향으로 발전하고 있다.

### 테스트 자동화와 변화

비행기는 시간이 흐르면서 내부의 부품이 계속 마모되는 변화가 발생한다. 소프트웨어는 외부 환경이 변화한다. 변화가 어느 쪽에서 일어나든 그것은 시스템 전반에 영향을 준다. 그 시스템이 복잡하다면 테스트 없이 생존할 수 없다.
테스트 자동화는 일반적이다. 우리가 사용하는 대부분의 개발 프레임워크의 가이드를 보면 테스트가 있다.

## 애자일 방법론

### 애자일 소개

집을 지을 때 처음 설계를 마치고 시공을 하는 중에도 끊임없이 수정하고 싶은 욕구가 생긴다. 여기에 전등을 달고 저기에 스위치를 옮기고 창은 좀 줄이고 등등.
이것은 인간이 창의적이기 때문이다. 그리고 이런 과정은 소프트웨어를 개발할 때도 마찬가지다.
요구사항은 계속 변한다. 그것이 고객의 요구이든 분석 단계에서 오류가 있든 간에 말이다.
애자일은 이런 요구사항의 변화에 대응하기 위한 개발 전략이다.

### 애자일과 변화

## cross-platform, 이 파트는 결론에 간단하게

### Java, NET 소개

.NET이 뒤늦게 나왔고 비교적 세련된 기술이다.
그럼에도 시장 점유율은 낮은 편이다. 개선된 장점이 흐름을 바꿀 만큼 크지 않은 것이다.

### Flutter, React Native 소개

### Docker 소개

> Linux® 컨테이너는 시스템의 나머지 부분과 분리된 1개 이상의 프로세스 세트입니다. 이러한 프로세스를 실행하는 데 필요한 모든 파일은 고유한 이미지에서 제공되므로, Linux 컨테이너는 개발 단계에서 테스트, 프로덕션에 이르기까지 이식성과 일관성을 유지할 수 있습니다. 따라서 전통적인 테스트 환경을 복제하는 데 의존하는 개발 파이프라인보다 사용 시점을 훨씬 더 앞당길 수 있습니다. 대중성과 사용의 편의성 때문에 컨테이너 역시 IT 보안의 중요한 부분입니다.

실행에 필요한 환경을 모두 하나의 패키지로 관리한다는 것은 응집성/의존성의 특징이다.

### 크로스 플랫폼과 변화

ios/android를 지원하는 Flutter, Java, .NET은 OS의 변화에 대응하기 쉬운 환경을 제공한다. 물론 one source multi use가 플랫폼의 의도였겠으나, 다양한 환경에 적응하는 플랫폼이라는 것은 변화에 잘 대응하는 플랫폼이라는 말과 같다.

## ORM(이것도 억지스럽네3)

### ORM 소개

ORM과 OOP의 관계

### ORM과 변화

typeorm, mybatis와 같은 ORM들은 다양한 SQL을 통일된 방법으로 사용할 수 있게 한다.
SQL 마다 문법이 조금씩 다르다. 본래의 취지는 말 그대로 Object Relation Modeling이겠으나 부수적인 효과로 통일된 인터페이스를 통한 SQL에 독립적인 코드를 지원한다.

## 결론

### 좋은 코드의 특징

지금까지 살펴본 개발방법과 도구들의 공통점은 변화에 대응한다는 것이다.
변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다.
그것은 코드도 마찬가지인데 좋은 코드는 변화에 적응하기 쉬운 특징을 가진다.
변화에 대응하기 좋은 코드의 특징은 의존성이 낮고 응집성이 높은 것이다.

그림(의존성/응집성)

그래서 패턴이나 아키텍쳐의 핵심은 규모가 다를 뿐이지 의존성/응집성에 대한 이야기다

의존성/응집성
다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 한다.

몇몇 책에서도 의존성과 응집성을 직접적으로 이야기 한다.
그렇지 않더라도 방법과 방법론에 대한 '모든' 서적은 변화에 대한 이야기다.

많은 이들이 개발 언어와 도구에 집착하는 것으로 보인다.
그러나 문제의 본질을 통찰하고 예측할 수 있다면 대응은 비교적 쉬운 편이고 도구도 올바르게 사용할 수 있다.


### 급변하는 개발환경에 대처하는 자세

React, NodeJS와 같은 응용기술이 변화가 빨라서 한 프로그래머가 여러 영역에 걸쳐서 전문성을 유지하기가 쉽지 않다.
패턴과 아키텍처와 같은 개발 이론의 지식은 쉽게 얻을 수 없으나 얻으면 모든 분야에 유용하다. 설계 없는 개발이 가능하겠는가.

어떤 이는 내가 아무리 잘 해도 다른 프로그래머들이 이해하기 어려운 기술은 실무에서는 쓸 수 없다고 말한다.
시니어나 팀장이 되면 전체적인 틀을 잡고 주니어들에게 가이드를 하며 작업을 진행한다.
이 때 소프트웨어 공학에 능숙하다면 더 나은 가이드를 할 수 있다.
나의 경우에는 프로젝트를 처음 시작할 때 내가 먼저 테스트를 포함한 기본적인 기능을 구현하면 팀원들이 그것을 응용해서 작업을 한다. 응용할 만한 것이 없는 경우에는 언제든지 내가 작업한다.
컴퓨터가 개발된 초기에는 하드웨어 성능이 부족했다. 그러나 지금은 성능에 여유가 있다. 그래서 소프트웨어는 성능 효율이 비교적 부족해도 변경 효율적인 쪽으로 발전하고 있다. 도커나 크로스플랫폼이 그렇다. 이에 맞춰서 현대의 좋은 코드는 변화에 잘 적응하는 코드다. 컴퓨터 초기라면 효율과 성능이 좋은 코드였겠지만 말이다.

### 이유
왜?가 제일 중요하다 우리가 접하는 많은 개발 방법과 도구들이 왜 그렇게 되었는지 이해하면 더 잘 이해할 수 있다.
